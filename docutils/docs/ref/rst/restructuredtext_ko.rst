.. -*- coding: utf-8 -*-

=======================================
 reStructuredText 마크업(Markup) 설명서
=======================================

:저자: David Goodger
:메일주소: docutils-develop@lists.sourceforge.net
:개정: $Revision$
:날짜: $Date$
:저작권: 이 문서는 공공 도메인에 속해있다.

.. note::

   이 문서는 튜토리얼이나 입문서가 아닌 상세한 기술 설명서다.
   만약 reStructuredText를 처음 접한다면, `A ReStructuredText Primer`_ 와
   `Quick reStructuredText`_ 사용자 레퍼런스(reference)를 먼저 읽기 바란다.

.. _A ReStructuredText Primer: ../../user/rst/quickstart_ko.html
.. _Quick reStructuredText: ../../user/rst/quickref_ko.html

reStructuredText_\ 는 단순하고 직관적인 구조를 이용해서 문서의 체계를 표현하는
일반 텍스트(plaintext)이다. 이 구조(construct)는 처리 전이나 후에 상관없이
읽기 쉽다. 이 문서는 이 자체로 reStructuredText의 예다. (예를 들어, 텍스트
문서를 읽고 있다면 처리되기 전이며, HTML을 읽고 있다면 처리된 후다.)
reStructuredText 파서(parser)는 Docutils_\의 구성요소이다.

단순하고, 암시적인(implicit) 마크업(markup)은 섹션 제목이나 글머리 기호 리스,
강조 같은 특수 구조(special construct)를 표현하기 위해 사용된다.
사용되는 마크업은 가능한 최소화되고 거슬리지 않게 되어있다.
적게 사용되는 구조나 기본 reStructuredText 신택스(syntax)의 확장 기능은
더 복잡하고 명시적(explicit)이다.

reStructuredText 는 인라인(inline) 프로그램 문서 부분(파이썬 독스트링(docstring))
처럼 매우 짧거나 이 문서처럼 매우 긴 길이의 문서에도 적용할 수 있다.

첫 번째 섹션은 reStructuredText 마크업 구문의 예시와 함께 간단한 개관으로
이루어져있다. 완전한 설명은 `구문 세부 정보`_ 섹션에서 제공된다.

마크업이 처리되지 않은 `리터럴 블럭`_\ 은 일반 텍스트 상태의 마크업을
보여주기 위해 사용되었다.


.. contents:: 목차

----------------
 빠른 구문 개요
----------------

reStructuredText 문서는 본문이나 블럭 레벨(block-level)의 요소로 구성되어 있으며
섹션으로 나눌 수 있다. `섹션`_\ 은 타이틀 스타일(언더라인(underlines)과
선택적인(optional) 오버라인(overlines))을 통해서 표시된다. 섹션은 본문 요소
(elements)와 하위 섹션을 포함하고 있다. 몇몇 본문 요소는 (단락과 기타 본문
요소를 포함하는) 리스트 항목 같은 추가적인 요소를 포함하고 있다. 단락과 같은
다른 본문 요소는 텍스트와 `인라인 마크업`_ 요소를 포함하고 있다.

`바디 요소`_ 예시:

- `단락`_ (과 `인라인 마크업`_)::

      단락은 텍스트와 인라인 마크업을 포함하고 있다:
      *강조*, **강한 강조**, `해석된(interpreted) 텍스트`, ``인라인 리터럴
      (literal)``, 자립형 하이퍼링크(standalone hyperlinks);
      (http://www.python.org), 외부 하이퍼링크(external hyperlinks);
      (Python_), 내부 상호 참조(internal cross-references); (예시_),
      각주 참조(footnote references); ([1]_), 인용 참조(citation references);
      ([CIT2002]_), 대체 참조(substitution references); (|예시|),
      _`인라인 내부 타겟(inline internal targets)`.

      단락은 빈 줄로 나눠져있고 왼쪽 정렬되어있다.

- 리스트 타입 다섯 가지:

  1. `글머리 기호 리스트`_::

         - 이것은 글머리 기호 리스트이다.

         - 글머리 기호(Bullet)는 "*", "+", "-"를 사용할 수 있다.

  2. `열거 리스트`_::

         1. 이것은 열거 리스트이다.

         2. 숫자는 아라비아 숫자, 글자 로마 숫자를 사용할 수 있다.

  3. `정의 리스트`_::

         개념
             정의 리스트는 용어와 용어를 정의하는 부분을 결합시킨다.

         사용 방식
             용어는 한 줄의 구문이고, 정의하는 부분은 하나 이상의 단락이나
             본문 요소로 구성되어 있으며 용어보다 들여쓰기 되어야 한다.

  4. `필드 리스트`_::

         :개념: 필드 리스트는 필드 이름(field names)과 데이터 베이스 기록과
                같은 필드 내용을 결합시킨다. 확장구문의 일부로 사용될 수 있다.

         :방법: 필드 표시는 콜론, 필드 이름, 콜론으로 나타낸다.

                필드의 본문은 하나 이상의 본문 요소를 포함하고 있으며
                필드 이름을 표시한 것보다 들여쓰기 되어 있어야 한다.

  5. `옵션 리스트`_, 커맨드라인 옵션(command-line options)을 위한 리스트::

         -a            커맨드라인 옵션 "a"
         -b file       인수(arguments)를 가지는 옵션과
                       그에 대한 긴 설명
         --long        긴(long) 옵션
         --input=file  긴 옵션 또한 인수를 가질 수 있다.
         /V            DOS/VMS 스타일 옵션도 가능하다

     옵션과 설명 사이에 최소한 두 칸 이상 공백이 있어야 한다.

- `리터럴 블럭`_::

      리터럴 블럭은 들여쓰기 되거나 라인 접두사로 인용된(line-prefix-quoted)
      블럭이며 선행된 단락의 끝에 더블 콜론(double-colon)("::")을 써서 나타낼
      수 있다. (이곳 처럼 -->)::

          if 리터럴_블럭에서는 :
              텍스트 = '그대로 표현된다'
              띄어쓰기와_개행 = '보존된다'
              마크업_처리 = 이루어지지 않는다

- `블럭 인용`_::

      블럭 인용(Block quotes)은 본문 요소를 들여쓰면 된다:

          This theory, that is mine, is mine.

          -- Anne Elk (Miss)

- `독테스트 블럭`_::

      >>> print '파이썬 사용 예제; ">>>"로 시작된다'
      파이썬 사용 예제; ">>>"로 시작된다
      >>> print '(대화형(interactive) Python 세션에서 복사, 붙여넣을 수 있다)'
      (대화형(interactive) Python 세션에서 복사, 붙여넣을 수 있다)

- `테이블`_\ 을 위한 두개의 구문:

  1. `그리드 테이블`_; 완전하지만 복잡하고 장황하다(verbose)::

         +-------------------+----------+--------+
         | 헤더 행, 1 열      | 헤더 2   | 헤더 3 |
         +===================+==========+========+
         | 본문 1 행, 1 열    | 2 열     | 3 열   |
         +-------------------+----------+--------+
         | 본문 2 행          | 셀 병합 가능       |
         +-------------------+-------------------+

  2. `단순 테이블`_;  쉽고 간결하지만 제한적이다::

         ====================  ==========  ==========
         헤더 행, 1 열            헤더 2      헤더 3
         ====================  ==========  ==========
         본문 1 행, 1 열          2 열        3 열
         본문 2 행                셀의 열 병합 가능
         ====================  ======================

- `명시적 마크업 블럭`_ 명시적 블럭 마커(explicit block marker,
  마침표 두 개, 스페이스 한 번)로 시작한다:

  - 각주_::

        .. [1] 각주는 적어도 스페이스 3번 이상으로 일관되게 들여쓰여진
           본문 요소를 포함한다.

  - 인용_::

        .. [CIT2002] 라벨이 문자인 것을 제외하면 각주와 같다.

  - `하이퍼링크 타겟`_::

        .. _Python: http://www.python.org

        .. _예시:

        위의 "_예시" 타겟이 이 단락을 가리킨다.

  - 명령어_::

        .. image:: mylogo.png

  - `대체 정의`_::

        .. |기호| image:: symbol.png

  - 코멘트_::

        .. 코멘트는 두 점과 스페이스 한 번으로 시작된다. 각주/인용 구문,
           하이퍼링크 타겟, 명령어(directives), 대체 정의(substitution definitions)
           를 제외하고는 어떤 것을 써도 상관 없다.

----------------
 구문 세부 정보
----------------


아래의 설명은 구문 구조에 대응하는 "독트리 요소" (문서 트리 요소의 이름
; XML DTD 일반 식별자(generic indentifier))를 나열하고 있다.  요소의 체계에
관한 세부사항은, `The Docutils Document Tree`_ 와 `Docutils Generic DTD`_
XML 문서 타입 정의를 참고하라.


공백
==========

`들여쓰기`_\ 는 스페이스를 사용할 것을 추천하지만 탭도 사용할 수 있다.
탭은 띄어쓰기로 변환될 것이다. 탭 위치(tab stop)는 8번째 열마다 있다.

다른 공백 문자 (폼 피드(form feeds) [chr(12)]와 수직 탭(vertical tabs)
[chr(11)])은 처리 전에 단일 스페이스로 변환된다.


공백 행
-----------

공백 행은 단락이나 다른 요소를 구분하기 위해 사용된다.
여러 줄의 공백 행은 모든 공백 문자가 보존되는 리터럴 블럭 안을 제외하고는
하나의 공백 행과 같다. 공백 행은 마크업이 요소 구분을 명확하게 할 때 들여쓰기와
함께 생략될 수 있다. 문서의 첫 번째 줄은 공백행이 앞에 있는 것으로 처리되며
문서의 마지막 줄은 공백 행이 다음에 오는 것으로 처리된다.


들여쓰기
-----------

들여쓰기는 블럭 인용이나 정의 리스트 항목 내의 정의, 지역적으로 내포되어있는
내용(local nested content)을 나타낼 때에만 중요하게 사용된다:

- list 항목 내용 (내포된 리스트를 포함해 리스트 항목의 여러줄짜리 내용과 본문 요소),
- 리터럴 블럭의 내용,
- 명시적 마크업 블럭의 내용.

현재 레벨에 비해 적게 들여쓰여진 (들여쓰기가 되지 않은 텍스트나 내어쓰기 된) 텍스트는
현재 레벨의 들여쓰기를 끝내버린다.

모든 줄의 들여쓰기가 중요하기 때문에, 들여쓰기 레벨은 일관성이 있어야 한다.
예를 들어, 들여쓰기는 `블럭 인용`_\  위한 유일한 마크업 표시기이다::

    이 단락은 레벨이 가장 높은 단락이다.

        이 단락은 첫 번째 레벨의 블럭 인용이다.

        첫 번째 레벨 블럭 인용의 단락 2이다.

블럭 인용 내에서 여러 레벨의 들여쓰기를 사용하면 구조를 복합적으로 만들 수 있다::

    이 단락은 레벨이 가장 높은 단락이다.

        이 단락은 첫 번째 레벨 블럭 인용에 속해 있다.

            이 단락은 두 번째 레벨 블럭 인용에 속해 있다.

    또 다른 가장 높은 레벨의 단락.

            이 단락은 두 번째 레벨 블럭 인용에 속해 있다.

        이 단락은 첫 번째 레벨 블럭 인용에 속해 있다. 위에 있는 두 번쨰 레벨
        블럭 인용은 이 첫 번째 레벨 블럭 인용의 안에 있다.

단락이나 다른 구조가 한 줄 이상의 텍스트로 구성되어 있을 때, 각 행은 반드시
왼쪽으로 정렬 되어 있어야 한다::

    이 부분은 한 단락이다. 이 단락의 각 행은
    왼쪽으로 정렬되어 있다.

        이 단락은 문제가 있다. 각 행이
    왼쪽으로 정렬되어 있지 않다. 이 경우
      해석이 잘못됨과 동시에 파서(parser)에 의해
        경고나 에러 메세지가
      발생할 것이다


몇몇 구조는 마커로 시작하고, 구조의 본문은 마커에 비해 반드시 들여쓰기
되어 있어야 한다. 간단한 마커를 사용하는 구조의 경우
(`글머리 기호 리스트`_, `열거 리스트`_, 각주_, 인용_,
`하이퍼링크 타겟`_, 명령어_, 코멘트_), 본문의 들여쓰기 레벨은
마커와 같은 줄에서 시작하는 텍스트의 첫 번째 줄 위치에 의해 결정된다.
예를 들어, 글머리 기호 리스트 본문은 글머리 기호(bullet)의 왼쪽 가장자리보다 최소한
두 열 이상은 들여쓰기 되어야 한다::

    - 이것은 글머리 기호 리스트 항목 단락의 첫 번째 줄이다.
      모든 줄은 반드시 첫 줄에 따라서 정렬되어야 한다.  [1]_

          이 들여쓰여진 단락은 블럭 인용으로 해석된다.

    이 단락은 충분히 들여쓰여지지 않았기 때문에
    리스트 항목에 속하지 않는다.

    .. [1] 이건 각주이며 두 번째 줄은 각주 레이블의 시작 부분에
       정렬되어 있다. 들여쓰기는 ".." 마커가 결정한다.

임의의 텍스트를 포함하는 복잡한 마커를 사용하는 구조 (`필드 리스트`_ 와 `옵션 리스트`_)는
마커의 *다음* 에 오는 첫 번째 줄이 본문의 왼쪽 가장자리를 결정한다.
예를 들어, 필드 리스트은 필드 이름이 굉장히 긴 마커를 쓸 수도 있다::

    :Hello: 이 필드는 짧은 필드 이름을 가지고 있다, 그렇기 때문에 같은 줄에서 부터
            본문을 정렬시켜도 문제가 없다.

    :Number-of-African-swallows-required-to-carry-a-coconut:
        이 필드 본문은 마커와 같은 줄에서부터 정렬시키기가 매우 힘들다.
        이 경우 마커와 같은 줄에서 본문을 시작하지 않는 것이 더 좋다.

이스케이핑 메커니즘
===================

7-bit ASCII 일반 텍스트 문서에서 일반적으로 사용 가능한 문자는 제한되어
있다. 마크업에 어떤 문자를 쓰더라도, 그 문자들은 텍스트에서 원래 여러 의미를 가지고
있을 것이다. 그러므로 마크업 문자는 가끔씩 **마크업으로 의도되지 않은 것처럼**
텍스트에서 나타나야 한다. 마크업 시스템은 마크업을 위해 사용되는 문자의 기본 의미를
무시하기 위한 이스케이핑 메커니즘(Escaping Mechanism)을 필요로 한다.
reStructuredText는 다른 도메인에서도 일반적으로 사용하는 백슬래쉬를 사용한다.

백슬래쉬는 (non-URI 컨텍스트(context) 내에서의 공백 문자를 제외한) 바로 뒤에 쓰여진
문자를 이스케이프(escape) 시킨다. 이스케이프된 문자는 문자 그 자체를 나타내고 마크업
역할을 하지 않는다. 백슬래쉬는 출력물에서 제외된다. 문자 그 자체로의 백슬래쉬는 백슬래쉬를
두 번 연달아 써서 나타낼 수 있다. (첫 번째 백슬래쉬가 두 번째 백슬래쉬를
이스케이프 하게 만들어서 두 번째 백슬래쉬가 이스케이핑 역할을 못 하도록 막는다.)

Non-URI 컨텍스트에서 백슬래쉬로 이스케이프된 공백 문자는 문서에서 제거된다.
이것은 문자 레벨의 `인라인 마크업`_\ 을 가능하게 한다.

URI에서는, 백슬래쉬로 이스케이프된 공백은 문자는 단일 스페이스로 나타난다.

백슬래쉬가 특수한 의미를 갖지 않는 컨텍스트는 두 가지가 있다:
바로 리터럴 블럭과 인라인 리터럴이다. 이 경우에는 백슬래쉬를 연달아 두 번 쓰지
않아도 백슬래쉬 그대로 표현된다.

reStructuredText 설명서와 파서는 입력 텍스트의 추출과 표현에 대한
이슈들(실제로 어떤 형식의 텍스트가 어떻게 파서에 도달하는지)을 다루지 않는다는
점을 참고하기 바란다. 백슬래쉬나 다른 문자들은 특정 컨텍스트 안에서 문자를
이스케이프시킬 목적으로로 사용될 수 있으므로 적절하게 다루어져야 한다.
예를 들어 파이썬은 문자열(string)에서 특정 문자를
이스케이프 시키기 위해 백슬래쉬를 사용하지만 다른 언어는 그렇지 않다.
파이썬 독스트링(doctsring)에서 백슬래쉬가 나타날 때 가장 쉬운 해결첵은
raw 독스트링을 사용하는 것이다::

    r"""이것이 raw doctring이다. 백슬래쉬 (\)는 처리되지 않는다)."""


참조 이름
==============

단순 참조 이름(simple reference name)은 영글자 숫자와 (인접하지 않게) 분리된
내부 하이픈, 언더스코어, 마침표, 콜론, 기호로 구성된 하나의 단어다; 공백이나
다른 문자는 사용할 수 없다. 각주 라벨 (각주_ & `각주 참조`_),
인용 라벨 (인용_ & `인용 참조`_), `해석된 텍스트`_, 기능(role)과
몇몇 `하이퍼링크 참조`_\ 는 단순 참조 이름 신택스를 사용한다.

구두점을 사용하거나 이름이 구문(두 개 이상의 띄어쓰기로 연결된 단어)인 참조 이름은
"구문 참조(phrase-references)"라고 한다.
구문 참조는 백 쿼트(backqouote)에 싸여진 구문으로 표현되고
백 쿼트 안의 구문이 참조 이름이 된다::

    `my favorite programming language`_ 에 대해서 배우고 싶은가?

    .. _my favorite programming language: http://www.python.org

단순 참조도 백쿼트를 사용할 수 있다.

참조 이름은 대소문자를 구분하지 않고 공백 중립적(whitespace-neutral)이다.
내부적으로 참조 이름을 변환할 때:

- 공백은 정규화 된다. 하나 이상의 스페이스, 수평, 수직 탭,
  개행(new line), 개행(carriage returns), 서식 이송(form feeds)은 하나의
  스페이스로 해석된다. 그리고,

- 문자도 표준화 된다. (모든 영어 문자는 소문자로 변환된다.)

예를 들어, 아래의 `하이퍼링크 참조`_\ 는 모두 동일하다::

    - `A HYPERLINK`_
    - `a    hyperlink`_
    - `A
      Hyperlink`_

`하이퍼링크`_, 각주_, 인용_\ 은 참조 이름에 대해서 같은 이름 공간(namespace)
을 공유한다. 인용 라벨 (단순 참조 이름)과 수동으로 번호가 매겨진 각주(숫자)는
다른 하이퍼링크 이름과 동일한 데이터베이스에 속하게 된다.
이 말은 각주 참조(``[1]_``)과 연결되는 각주("``.. [1]``")는
하이퍼 링크 참조(1_) 와도 연결될 수 있다는 의미이다.
물론, 각 종류의 참조(하이퍼링크, 각주, 인용)는 다른 방식으로
해석되고 처리될 것이다. 따라서 참조 이름의 충돌을 피하기 위해서는 주의가 필요하다.


문서 구조
==================

문서
--------

독트리(Doctree) 요소: 문서.

파싱된 reStructuredText 문서의 최상위 레벨 요소는 "문서" 요소다.
최초의 파싱이 끝나면, 문서 요소는 `바디 요소`_, 전환_,
섹션_\ 으로 구성된 문서 조각(fragment)을 포함하는 단순한 컨테이너이며, 문서 제목이나
다른 서지(bibliographic) 요소는 없다. 파서를 호출하는 코드는 하나 이상의 추가적인
포스트-파스 변환_ (post-parse transforms)을 실행시킬 수 있으며, 문서 조각을 제목과 기타 메타데이터 요소
(저자, 날짜 등; `서지 필드`_ 참고)를 가진 완전한 문서로 재배열 합니다.

.. _문서 제목:

엄밀히 말하면, reStructuredText에서 문서 제목과 부제목을 명시적으로 표현할 수
있는 방법은 없다. [#]_ 대신, 하나의 최상위 레벨 섹션 타이틀(아래의 섹션_ 참고)
을 문서의 제목으로 처리할 수 있다.
마찬가지로 하나의 차 상위 레벨의 섹션 제목을 문서 제목의 바로 아래에 놓으면
문서의 부제목으로 처리할 수 있다. 그러면 나머지 섹션은 레벨이 1, 2단계씩 오르게 된다.
자세한 내용은 `독타이틀 변환`_\ 을 참고하라.

.. [#] `제목`_ 설정을 변경하면 문서의 제목을 문서 본문의 일부가 되지 않도록
   조정할 수 있다.

.. _제목: ../../user/config.html#title


섹션
--------

독트리 요소: 섹션, 제목.

섹션은 마크업을 통해 꾸며진 각 섹션의 제목을 통해 식별된다:
타이틀 텍스트 아래에 "언더라인" 표시를 하거나 언더라인에 맞춰서 "오버라인"까찌 표시.
오버라인/언더라인은 단일 구분 문자를 줄의 처음부터 적어도 제목 텍스트의
오른쪽 끝까지 반복해서 형성한 줄을 말한다. 언더라인/오버라인에 사용하는 문자는 글자와
숫자가 아니면서 출력 가능한 7-bit ASCII 문자면 된다 [#]_.
오버라인까지 사용할 경우 사용하는 문자와 줄의 길이가 언더라인과 같아야 된다.
언더라인만 사용된 꾸미기(adornment) 스타일은 같은 문자를 사용한 밑줄 윗줄 스타일과 구분된다.
비록 몇몇 출력 형식에 제한이 있기는 하지만 (HTML은 6레벨 까지) 섹션 제목의 레벨은
제한이 없다.

.. [#] 아래는 섹션 타이틀 꾸미기에 사용될 수 있는 문자들이다::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   몇가지 문자들은 다른 문자에 비해 더 적합하다. 아래의 문자들이
   권장된다::

       = - ` : . ' " ~ ^ _ * + #

순서는 고정된 섹션 제목 꾸미기 스타일과 숫자를 강제로 지정하는 것이 아니라,
쓰여진 순서대로 자동적으로 정해진다. 첫 번째로 쓰여진 스타일이 가장 바깥쪽
(outermost) 타이틀이 되고, 두 번째 스타일이 부제목, 세 번째가 부부제목이 되는
식이다.

아레는 제목 스타일의 예시다::

    ===========
      섹션 제목
    ===========

    -----------
      섹션 제목
    -----------

    섹션 제목
    =========

    섹션 제목
    ---------

    섹션 제목
    `````````

    섹션 제목
    '''''''''

    섹션 제목
    .........

    섹션 제목
    ~~~~~~~~~

    섹션 제목
    *********

    섹션 제목
    +++++++++

    섹션 제목
    ^^^^^^^^^

제목에 언더라인과 오버라인이 모두 있을 때, 제목 텍스트는 위쪽의 처음 두
예시와 같이 가운데 정렬할 수 있다. 이것은 단지 미적인 이유 때문일 뿐
중요한 것은 아니다. 언더라인만 쓰는 경우는 텍스트를 들여쓰면 *안* 된다.

제목 아래에 공백 행을 쓰는 것은 선택적인 부분이다. 동일하거나 더 높은
레벨 전까지의 텍스트 블럭은 한 섹션(또는 하위 섹션 등)에 포함된다.

모든 섹션 제목 스타일이 다 쓰일 필요는 없으며, 특정한 제목 스타일만 쓸 필요도
없다. 단, 문서는 섹션 제목 사용에 있어서 일관성을 유지해야 한다: 제목 스타일의
쳬계가 일단 정해지면, 모든 섹션은 반드시 그 체계를 따라야 한다.

섹션의 제목은 자동적으로 각 섹션을 가리키는 하이퍼 링크 타겟을 생성한다.
하이퍼 링크 타켓의 텍스트("참조 이름")는 섹션 제목이다. 자세한 설명은 `암시적 하이퍼링크 타겟`_\ 을 참고하라.

섹션은 `바디 요소`_, 전환_, 내포된 섹션을 포함할 수 있다.


전환
--------

독트리 요소: 전환.

    부제를 다는 것 대신에, 단락 사이에 빈 공간을 두거나 기호를 입력하는 것으로
    텍스트를 분리하고 주제가 전환됨을 표현할 수 있다.

    (The Chicago Manual of Style, 14th edition, section 1.80)

전환은 소설에서 자주 볼 수 있는데, 별표로 된 줄 같은 장식을 쓰거나 한 줄 이상으로
간격을 벌려놓은 것을 말한다. 전환은 다른 본문 요소를 분리시킨다.
전환은 섹션이나 문서를 시작하거나 끝낼 수 없으며, 두개의 전환 부분이
바로 붙어 있을 수도 없다.

전환 마커를 위한 신택스는 구분 문자를 4번 이상 수평적으로 반복시킨 것이다.
이 신택스는 제목 텍스트가 없는 섹션 타이틀 언더라인과 똑같다.
전환 마커 라인의 위, 아래에는 공백 행이 필요하다::

    파라.

    ----------

    파라.

섹션 제목 언더라인과 다르게, 전환 마커의 계층 구조는 존재하지 않으며
전환 마커의 차이는 아무 것도 발생시키지 않는다. 따라서 단일한
일관된 스타일을 사용할 것을 추천한다.

프로세싱 시스템은 원하는 방식으로 자유롭게 전환을 렌더링할 수 있습니다.
예를 들어, HTML 출력에서는 수평줄 (``<hr>``)이 선택될 것이다.


바디 요소
=============

단락
----------

독트리 요소: 단락.

단락은 다른 본문 요소를 표시하는 마크업이 없는 왼쪽으로 정렬된 텍스트 블럭으로
구성되어 있다. 공백 행은 단락을 다른 본문 요소나 단락과 구분지어 준다. 단락은
`인라인 마크업`_\ 을 포함할 수 있다.

신택스 다이어그램::

    +------------------------------+
    | 단락                         |
    |                              |
    +------------------------------+

    +------------------------------+
    | 단락                         |
    |                              |
    +------------------------------+


글머리 기호 리스트
------------------

독트리 요소: 글머리 기호 리스트, 리스트 항목.

"*", "+", "-", "•", "‣", "⁃"로 시작하고 공백 문자로 띄어진 텍스트 블럭은
글머리 기호 리스트 항목(순서가 없는 리스트 항목)이라고 한다. 리스트 항목의
본문은 반드시 글머리 기호(bullet)보다 들여쓰여진 상태로 왼쪽 정렬 되어
있어야 한다; 글머리 기호 바로 다음에 오는 첫 번째 텍스트가 들여쓰기를 결정한다.
예를 들면::

    - 이것은 첫 번째 글머리 기호 리스트 항목이다. 첫 번째 리스트 항목의 위에는
      공백 행이 있어야 한다; 이 단락의 아래처럼 리스트 항목 사이에 공백 행을
      쓰는 것은 선택적인 부분이다.

    - 이것은 리스트의 두 번째 항목의 첫 번째 단락이다.

      이 두 번째 단락은 두 번째 항목의 속해있다. 이 단락의 위에는 공백 행이
      삽입 되어야 한다. 이 단락의 왼쪽 가장자리는 위쪽에 있는 단락에 맞춰야 하며
      모두 글머리 기호보다 들여쓰여져야 한다.

      - 이것은 하위 리스트다. 글머리 기호의 왼쪽 가장자리는 위쪽 텍스트 블럭의
        가장자리를 따라야 한다. 하위 리스트는 또다른 새로운 리스트이기 때문에
        항목의 위 아래에 공백 행이 삽입되어야 한다.

    - 이것은 메인 리스트의 세 번째 항목이다.

    이 단락은 리스트에 속해있지 않다.

아래는 **잘못** 작성된 글머리 기호 리스트의 예시이다::

    - 첫 번째 줄은 이상이 없다.
    리스트 항목과 단락 사이에는 공백 행이 삽입되어야 한다.
    (경고)

    - 아래의 몇 줄들은 새로운 하위 리스트로 보이지만 실제로는 그렇지 않다:
      - 사이에 공백 행이 삽입되지 않았기 때문에 이것은 하위리스트가
        아니라 연결된 단락이다. 그리고 들여쓰기도 제대로 되어있지 않은 상태다.
      - 이러한 경우 변환 시에 경고가 발생될 수 있다.

신택스 다이어그램::

    +------+-----------------------+
    | "- " | 리스트 항목            |
    +------| (본문 요소)+           |
           +-----------------------+


열거 리스트
------------------

독트리 요소: 열거 리스트, 리스트 항목.

열거 리스트("순서가 있는" 리스트)는 글머리 기호 리스트와 비슷하지만
글머리 기호 대신에 숫자나 문자를 사용한다. 열거자(enumerator)는
열거 시퀀스(enumeration sequence) 멤버와 포맷팅(formatting), 바로 뒤의
공백문자로 구성되어 있다. 열거 시퀀스는 아래 다섯 종류를 사용할 수 있다:

- 아라비아 숫자: 1, 2, 3, ... (수에 제한이 없다).
- 알파벳 대문자: A, B, C, ..., Z.
- 알파벳 소문자: a, b, c, ..., z.
- 로마 숫자 대문자: I, II, III, IV, ..., MMMMCMXCIX (4999).
- 로마 숫자 소문자: i, ii, iii, iv, ..., mmmmcmxcix (4999).

그리고 자동 열거자인 "#"를 사용하면 자동적으로 리스트에 숫자를 매길
수 있다. 자동 열거 리스트는 시퀀스를 설정하는 명시적 열거로 시작한다.
완전 자동 열거 리스트는 아라비아 숫자를 사용하고 1로 시작한다.
(자동 열거 리스트는 Docutils 0.3.8.에서 새로 등장했다)

포매팅 스타일은 아래 세 가지가 인식된다:

- 구두점이 뒤에 붙은 타입: "1.", "A.", "a.", "I.", "i.".
- 괄호에 싸인 타입: "(1)", "(A)", "(a)", "(I)", "(i)".
- 괄호가 오른쪽에만 붙은 타입: "1)", "A)", "a)", "I)", "i)".

열거 리스트를 파싱 할 때, 아래의 경우에는 새로운 리스트가 시작된다:

- 열거자가 현재의 리스트와 다른 시퀀스 타입과 포매팅 스타일을 사용했을 경우
  ("1.", "(a)"를 쓰면 두 개의 리스트를 생성한다).

- 열거자의 순서가 맞지 않는 경우("1.", "3." 두 개의 리스트
  생성한다).

첫 번째 리스트 항목의 열거자로 는시퀀스의의 첫 번째 문자
("1", "A", "a", "I", or "i")를 사용하는 것을 추천한다. 다른 문자로 시작
해도 되지만 출력 포맷이 지원해주지 못할 수도 있다. 첫 번째 문자가 아닌
다른 문자로 리스트를 시작하면 level-1 [info] 시스템 메세지가 발생할 것이다.

로마 숫자를 사용하는 리스트는 반드시 "I"/"i"나, "II", "XV" 같이 여러 개로
이루어진 문자로 시작해야 한다. 다른 한 글자 짜리 로마 문자
("V", "X", "L", "C", "D", "M")로 시작하면 로마 숫자가 아니라 알파벳
글자로 해석될 것이다. 마찬가지로 알파벳을 사용하는 리스트는 로마 숫자로
인식될 수 있기 때문에 "I"/"i"로 시작하면 안 된다.

각 열거 리스트 항목의 두 번째 줄은 리스트의 유효성을 확인하는데 사용된다.
이는 텍스트가 열거자와 동일한 문자로 시작했을 때 일반적인 단락을 잘못해서
리스트 항목으로 인식되는 것을 막기 위함이다. 예를 들면 아래의 텍스트는
일반적인 단락으로 파싱된다::

    A. Einstein was a really
    smart dude.

그러나, 단락이 한 문장일 경우 판단이 애매해진다.
아래의 텍스트는 열거 리스트 항목으로 파싱된다::

    A. Einstein was a really smart dude.

단락이 열거자와 동일한 문자("A.", "1.", "(b)", "I)" 등)로 텍스트가
시작된다면 일반적인 단락으로 파싱되기 위해 이스케이프 되어야 한다::

    \A. Einstein was a really smart dude.

열거 리스트 내에 열거 리스트가 있는 예시::

    1. 항목 1 시작하는 텍스트.

       a) 항목 1a.
       b) 항목 1b.

    2. a) 항목 2a.
       b) 항목 2b.

신택스 다이어그램 예시::

    +-------+----------------------+
    | "1. " | 리스트 항목           |
    +-------| (본문 요소)+          |
            +----------------------+


정의 리스트
----------------

독트리 요소: 정의 리스트, 정의 리스트 항목, 용어,
구분자(classifier), 정의.

각각의 정의 리스트 항목은 용어와 선택적인 구분자, 정의로
이루어져 있다. 용어는 한 줄의 구문이나 단어이다. 선택적인 구분자는 용어와
같은 줄에서 " : " (공백, 콜론, 공백) 다음에 위치한다. 정의는 용어보다 들여쓰기
된 블럭이며 여러 단락과 다른 본문 요소들을 포함할 수 있다.
정의 블럭과 용어 줄 사이에는 공백 행이 있어서는 안된다(이 부분으로 정의 리스트와
`블럭 인용`_\  구분한다). 정의 리스트의 첫 번째 항목의 위쪽과
마지막 항목의 아래쪽에는 공백 행이 삽입 되어야 하며 그 사이에는 선택적으로
삽입할 수 있다::

    용어 1
        정의 1.

    용어 2
        정의 2, 단락 1.

        정의 2, 단락 2.

    용어 3 : 구분자
        정의 3.

    용어 4 : 구분자 1 : 구분자 2
        정의 4.

인라인 마크업은 구분자 구분 기호 (" : ")가 인식되기 전에 파싱된다.
구분기호는 인라인 마크업의 외부에서 나타날 때에만 인식된다.

정의 리스트는 다양한 방식으로 사용될 수 있다:

- 사전으로 사용할 수 있다. 용어를 단어로 쓰고, 구분자로 용어의
  품사(명사, 동사 등)를 나타내고 아래에서 뜻을 정의하면 된다.

- 프로그램 변수를 설명할 때 사용할 수 있다. 용어는 변수 이름으로 놓고,
  구분자로 변수의 타입(string, integer, etc.)을 표시하고 프로그램에서
  변수가 어떻게 사용되는지 정의하면 된다. 이 정의 리스트를 사용하면
  파이썬 객체(object) 스키마(scheme)를 기술하고 실행하는 시스템인 Grouch_\ 의
  구분자 신택스가 지원된다.

신택스 다이어그램::

    +----------------------------+
    | 용어 [ " : " 구분자       ]* |
    +--+-------------------------+--+
       | 정의                        |
       | (본문 요소)+                 |
       +----------------------------+


필드 리스트
-----------

독트리 요소: 필드 리스트, 필드, 필드 이름, 필드 본문.

필드 리스트는 명령어_\ 를 위한 옵션 같은 신택스 확장 기능의 일부나 추가적인
처리를 위한 데이터 베이스 형태의 기록을 위해 사용된다. 또한 데이터 베이스
기록(라벨 & 데이터 쌍)과 유사한 2열 테이블형태의 구조에도 사용될 수 있다.
reStructuredText 응용 프로그램은 필드 이름을 인식하고 특정 내용의
필드나 필드 본문을 변환할 수 있다. 예시를 확인하려면, 아래의
`서지 필드`_ 또는, `reStructuredText Directives`_
내에 있는 "image_", "meta_" 명령어(directives)를 참고하라.

.. _field names:

필드 리스트은 RFC822_ headers을 모델로 *필드 이름* 을 *필드 내용* 으로
맵핑(mapping)한다. 필드 이름은 어떤 문자로 되어 있어도 상관 없지만
안에 콜론(":")을 사용해야 될 경우 백슬래쉬를 사용해 이스케이프 시켜야한다.
인라인 마크업은 필드 이름 안에서 파싱된다. 필드 이름은 추가적으로 처리되거나
변환될 때 대소문자를 구분하지 않는다. 앞, 뒤에 붙은 콜론과 필드 이름은
합쳐서 하나의 필드 마커를 형성한다. 필드 마커 뒤에는 공백문자와 필드 본문이
위치한다. 필드 본문은 필드 마커에 비해 들여쓰여져야 하며 여러 본문 요소를
포함할 수 있다. 필드 마커 뒤의 첫 번째 줄이 필드 본문의 들여쓰기를 결정한다::

    :날짜: 2001-08-16
    :버전: 1
    :저자: - Me
              - Myself
              - I
    :들여쓰기: 필드 마커가 꽤 길 수도 있기 때문에, 필드 본문의 두 번째와 이후의
       행들은 첫 번째 행과 정렬될 필요는 없지만 필드 이름 마커에 비해서는 들여쓰기
       되어야 한다. 그리고 그 행들은 서로 정렬되어있어야 한다.
    :모수 i: 정수

여러 단어로 이루어진 필드 이름 안의 개별적인 단어들의 해석은 응용 프로그램에 따라
다르다. 응용 프로그램은 필드 이름에 대한 신택스를 지정할 수 있다.
예를 들어 두 번째와 이후의 단어가 "인수(argument)"로 처리된다면 인용된 구절은
단일 인수로 다루어질 수 있고 "이름=값" 신택스에 대한 직접적인 지원이
추가될 수 있다.

Standard RFC822_ headers는 규정이 애매하기 때문에 이 구조를 위해 사용될
수 없다. 줄의 시작 부분에 있는 콜론 앞의 단어는 텍스트에서 공통적이다.
그러나 문서의 시작 부분에서 filed list가 일관되게 쓰여지는 경우처럼(PEP,
이메일 메세지 등) 잘 정의된 컨텍스트에서는 standard RFC822 headers도 사용될 수 있다.

단순화시킨 신택스 다이어그램::

    +--------------------+----------------------+
    | ":" 필드 이름 ":"    | 필드 본문              |
    +-------+------------+                      |
            | (본문 요소)+                        |
            +-----------------------------------+


서지 필드
````````````````````

독트리 요소: 문서 정보(docinfo), 저자, 기관, 연락처,
버전, 상태, 날짜, 저작권, 필드, 주제.

필드 리스트가 문서 내에서 주석이 아닌 첫 번째 요소일 때(제목이 있으면
제목 다음에), 필드는 문서의 서지(bibliographic) 자료로 변형될 수 있다.
이 서지 자료는 책의 제목 페이지나 저작권 페이지 처럼 책의 전문(front matter)과
일치한다.

(아래에 있는) 지정된 특정한 필드 이름은 인식 된 다음 일치하는 독트리 요소로
변환되는데 대부분 "문서 정보" 요소의 하위 요소가 된다. 문서 구조에 맞춰서
재배열 될 수는 있지만 순서를 지정할 필요는 없다.
아래 쪽에서 달리 명시하지 않는 한, 문헌 요소의 각 필드 본문은 하나의 단락만
포함할 수 있다. 필드 본문은 `RCS 키워드`_\ 에 대해 확인되고 정리될 수 있다.
인식되지 않은 필드는 문서 정보 요소 안의 일반 필드로 남겨진다.

지정된 서지 필드 이름과 대응하는 독트리 요소는 다음과 같다:

- 필드 이름 "Author": author element.
- "Authors": authors.
- "Organization": organization.
- "Contact": contact.
- "Address": address.
- "Version": version.
- "Status": status.
- "Date": date.
- "Copyright": copyright.
- "Dedication": topic.
- "Abstract": topic.

"Authors" 필드는 ";"나 ","로 구분된 저자 리스트로 구성된 한 단락을 포함할수도
있고 각 요소가 저자 한 명당 한 단락으로 구성된 글머리 기호 리스트를 포함할 수도 있다.
";"가 먼저 확인되기 때문에 "Doe, Jane; Doe, John"로 쓸 수 있다.
스웨덴어 같은 특정한 언어의 경우 "Author"와 "Authors" 사이에 단복수 구분이 없기
때문에 "Authors" 필드만이 제공된다. 그리고 한 사람의 이름은 "Author"로
해석된다. 만약 한 사람의 이름이 콤마를 포함한다면 구분을 해주기 위해서
이름의 끝에 세미콜론을 써야 한다: ":Authors: Doe, Jane;".

"Address" 필드는 여러줄로 된 우편 주소를 위한 것이다.
개행과 공백 문자가 보존된다.

"Dedication"과 "Abstract" 필드는 임의의 본문 요소를 포함할 수 있다.
그러나 각각 하나씩만 포함할 수 있다. 본문 요소는
문서 정보 요소 바로 뒤에 "Dedication"이나 "Abstract" 제목을 가진 주제
요소가 된다.

이 field-name-to-element 맵핑은 다른 언어로 대체될 수 있다.
자세한 내용은 `독인포 변환`_ 구현 문서를 참고하라.

지정되지 않았거나 일반적인(generic) 필드는 하나 이상의 단락이나 임의의
본문 요소를 포함할 수 있다. 필드 이름은 유요한 식별자 형식으로 변환된 후
"classes" 속성 값으로도 사용된다.


RCS 키워드
````````````

파서에 의해 인식된 `서지 필드`_\ 는 일반적으로 RCS [#]_ 키워드에
대해 확인되고 정리된다 [#]_.  RCS 키워드는 "$keyword$" 형식으로
소스 파일에 입력될 수 있고 일단 RCS나 CVS [#]_ 에 저장되면,
"$keyword: expansion text $"로 확장된다. 예를 들어, "Status" 필드는
"status" 요소로 변형될 것이다::

    :Status: $keyword: expansion text $

.. [#] Revision Control System.
.. [#] RCS keyword 처리를 중지시킬 수 있다 (구현되지 않음).
.. [#] Concurrent Versions System.  CVS는 RCS와 같은 키워드를 사용한다.

처리된 "status" 요소의 텍스트는 단순히 "expansion text"가 된다.
달러 표시 기호와 주요 RCS keyword 이름은 제거된다.

RCS keyword 처리는 필드 리스트가 서지 컨텍스트에 있을 때만 시작된다.
(문서의 첫 번째 비 주석(comment) 구조, 제목이 있는 경우 제목 다음에 있는 첫 비 주석 구조).


옵션 리스트
------------

독트리 요소: 옵션 리스트, 옵션 리스트 항목, 옵션 그룹, 옵션,
옵션 스트링, 옵션 인수, 설명.

옵션 리스트 커맨드라인 옵션, 설명, 프로그램 옵션 기록에 대한 리스트다.

예시::

    -a         전부 출력.
    -b         둘 다 출력 (이 설명은 조금
               길다).
    -c arg     인수만 출력.
    --long     하루종일 출력.

    -p         이 옵션은 설명이 두 단락으로 이루어져있다.
               이 단락이 첫 번째다.

               이 단락이 두 번째다. 옵션 사이의 공백 행은 위처럼 생략되거나
               여기나 아래처럼 남아있을 수 있다.

    --very-long-option  VMS 스타일 옵션. 두 칸의 공백이 요구된다는
                        사실을 명심하라.

    --an-even-longer-option
               설명 부분은 다음줄부터 시작해도 된다.

    -2, --two  이 옵션은 두 변형(variants)이 있다.

    -f FILE, --file=FILE  이 두 옵션의 의미는 같다; 둘 다 인수를
                          받는다.

    /V         VMS/DOS 스타일 옵션.

reStructuredText에 의해 인식되는 옵션 종류는 여러가지가 존재한다:

- 짧은 POSIX 옵션은 대쉬 하나와 한 글자짜리 옵션으로 구성되어 있다.
- 긴 POSIX 옵션은 대쉬 두 개와 한 단어로 구성되어 있다; 몇몇 시스템은
  대쉬 하나를 사용한다.
- 구식 GNU 스타일 "플러스" 옵션은 플러스기호 하나와 한 글자 옵션으로
  구성되어 있다 ("플러스" 옵션은 사라졌으며, 사용이 권장되지 않는다).
- DOS/VMS 옵션은 슬래쉬 하나와 옵션 한 글자 또는 한 단어로 구성되어 있다.

POSIX 스타일과 DOS/VMS 스타일 옵션은 도스나 윈도우즈 소프트웨어에서
모두 사용 가능하다. 위 스타일과 다른 변형은 종종 혼합되어 사용된다.
위의 이름은 단순히 편의를 위해서 선택되었다.

짧고 긴 POSIX 옵션을 위한 구문은 Python's getopt.py_ 모듈에 의해 지원되는
구문을 기반으로 한다. 이 모듈은 `GNU libc getopt_long()`_ 함수와 유사한 옵션
파서를 구연하지만 일부 제한이 있다. reStructuredText 옵션 리스트는 모든 변형
옵션 시스템을 지원하지는 않는다.

긴 POSIX와 DOS/VMS 옵션 단어는 커맨드라인에서 사용될 때 운영 시스템이나
응용 프로그램에 의해 잘릴 수 있지만, reStructuredText 옵션 리스트는
특수 구문으로 표시하거나 지원하지 않는다. 적용이 가능하다면
생략(truncation)에 대한 문서에 의해 지원되는 완전한 옵션 단어를 제공해야 한다.

옵션 뒤에는 인수 플레이스 홀더가 올 수 있는데 설명 부분에서 역할과 구문에 대한
안내를 해주어야 한다. 옵션과 인수 placeholder 사이에 스페이스나 등호를
구분 기호로 사용할 수 있다. "-" 또는 "+"만 사용 가능한 짧은 옵션은 구분 기호를
생략할 수 있다. 옵션 인수는 아래의 두 가지 형식중 하나를 차용해야 한다:

- 알파벳(``[a-zA-Z]``)으로 시작하고 문자, 숫자, 하이픈(``[a-zA-Z0-9_-]``)
  으로 구성되어야 한다.
- 화살괄호로 시작(``<``)해서  화살괄호로 끝나야(``>``) 한다; 괄호 내에서는
  화살괄호를 제외하고 어떤 문자를 써도 상관이 없다.

하나의 설명을 공유하는 여러 옵션 '동의어'가 나열될 될 수 있다.
그 경우 콤마와 스페이스로 구분돼야 한다.

옵션과 설명 부분은 최소한 두 칸의 스페이스로 떨어져 있어야 한다.
설명은 여러 본문 요소를 포함할 수 있다. 옵션 마커 다음 첫 줄이 설명 부분의
들여쓰기를 결정한다. 다른 종류의 리스트와 마찬가지로 옵션 리스트의 첫 번쨰
항목의 앞과 마지막 항목의 뒤에 공백 행이 삽입되어야 하며 옵션 사이에서는
선택적으로 사용할 수 있다.

단순화된 신택스 다이어그램::

    +----------------------------+-------------+
    | 옵션   [" " 인수]      "  "  | 설명         |
    +-------+--------------------+             |
            | (본문 요소)+                       |
            +----------------------------------+


리터럴 블럭
--------------

독트리 요소: 리터럴 블럭.

두 개의 콜론("::")으로 구성된 단락은 다음에 오는 텍스트 블락을 리터럴 블럭
으로 변형시킨다. 리터럴 블럭은 들여쓰여지거나 인용 되어야 한다.
리터럴 블럭 안에서는 마크업 처리가 되지 않는다. 일반적으로 고정폭 글꼴로
렌더링 된 채 있는 그대로 유지된다::

    이것은 일반적인 단락이다. 들여쓰여진 리터럴 블럭이 다음에 위치한다.

    ::

        for a in [5,4,3,2,1]:   # 보이는 것처럼 이것은 프로그램 코드다
            print a
        print "it's..."
        # 리터럴 블럭은 들여쓰기가 끝나기 전까지 계속 이어진다

    이 텍스트는 첫 번째 단락의 들여쓰기 수준으로 돌아왔고, 리터럴 블럭의
    밖에 있기 때문에 일반적인 단락으로 처리된다.

콜론 두 개만으로 구성된 단락은 출력에서 완전히 제거된다. 빈 단락이
남아 있지 않는다.

편의상 "::"는 단락의 끝에서 인식된다. 공백 문자 바로 앞에 쓰여지면 두 콜론은
출력에서 모두 제거된다 (이것은 "부분적으로 최소화된" 형식이다).
"::" 바로 앞에 텍스트가 오면, *하나의* 콜론만 출력에서 제거되고 하나의 콜론은
남아서 보이게 된다 (즉, "::"가 ":"로 대체된다; 이것은 "완전히 최소화된" 형식이다).

다시 말해서 아래의 형태는 모두 동일하다 (단락 다음에 오는 콜론에 주목하라):

1. 확장된 형태::

      단락:

      ::

          리터럴 블럭

2. 부분적으로 최소화된 형태::

      단락: ::

          리터럴 블럭

3. 완전히 최소화된 형태::

      단락::

          리터럴 블럭

리터럴 블럭의 들여쓰기를 위해 필요한 최소한의 부분을 제외한 모든 공백
문자는 보존된다. 리터럴 블럭의 전후로 공백 행이 필요하지만 공백 행은
리터럴 블럭의 일부로 포함되지는 않는다.


들여쓰기된 리터럴 블럭
```````````````````````

들여쓰기된 리터럴 블럭 주변 텍스트에 비해 들여쓰여져서 표기된다
(각 줄이 공백 문자로 시작해야 함). 들여쓰기된 리터럴 블럭의 각 라인에서
최소로 들여쓰기 부분은 제거 된다. 리터럴 블럭은 연결되어 있을 필요는 없다;
들여쓰기된 텍스트의 섹션 사이에 공백 행을 삽입할 수 있다. 리터럴 블럭은
들여쓰기가 끝나는 부분에서 종료 된다.

신택스 다이어그램::

    +------------------------------+
    | 단락                          |
    | ("::"로 끝남)                 |
    +------------------------------+
       +---------------------------+
       | 들여쓰기된 리터럴 블럭    |
       +---------------------------+


인용된 리터럴 블럭
`````````````````````

인용된 리터럴 블럭은 들여쓰기 되지 않은 이어진 텍스트 블럭이며 각 행은
출력가능하면서 숫자나 문자가 아닌 동일한 7-bit ASCII 문자 [#]_\ 로 시작한다.
인용 문자는 처리된 문서에서 그대로 보존된다.

.. [#]
   아래는 사용 가능한 인용 문자들이다::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   위 문자들은 섹션_\ 의 제목을 꾸밀 때 사용 가능한 문자들과 같다.

대화형 하스켈 프로그래밍이나 이메일 인용이 필요할 때 사용 가능하다::

    John Doe wrote::

    >> Great idea!
    >
    > Why didn't I think of that?

    You just did!  ;-)

구문 다이어그램::

    +------------------------------+
    | 단락                          |
    | ("::"로 끝남)                 |
    +------------------------------+
    +------------------------------+
    | ">" 인용된 라인                 |
    | ">" 공백 행 없이 이어져야 함      |
    +------------------------------+


라인 블럭
-----------

독트리 요소: 라인 블럭, 행. (Docutils 0.3.5.부터 가능)

라인 블럭은 행의 구조가 중요한 주소 블럭(address blocks), 운문(verse)
(시, 노래 가사), 간소한 리스트 등을 나타낼 때 유용하다. Line blocks은
수직 막대("|")로 시작하는 행들의 그룹이다. 각각의 수직 막대는 새로운 행을
나타내기 떄문에 개행도 유지된다. 첫 번째 들여쓰기 또한 내포된(nested)된 구조를
형성하기 때문에 중요하다. 인라인 마크업이 지원된다.
연속 행(Continuation lines)은 긴 행이 래핑된(wrapped) 부분이다;
수직 막대 대신에 스페이스로 시작한다. 연속 행은 반드시 들여쓰여져야 하지만
위쪽의 텍스트와 왼쪽으로 똑같이 정렬되어 있을 필요는 없다. 라인 블럭은
공백 행으로 끝난다.

아래는 연속 행을 설명하는 예시다::

    | Lend us a couple of bob till Thursday.
    | I'm absolutely skint.
    | But I'm expecting a postal order and I can pay you back
      as soon as it comes.
    | Love, Ewan.

새로운 행의 들여쓰기로 표시된 라인 블럭의 내포된 구조를 보여주는
예시::

    Take it away, Eric the Orchestra Leader!

        | A one, two, a one two three four
        |
        | Half a bee, philosophically,
        |     must, *ipso facto*, half not be.
        | But half the bee has got to be,
        |     *vis a vis* its entity.  D'you see?
        |
        | But can a bee be said to be
        |     or not to be an entire bee,
        |         when half the bee is not a bee,
        |             due to some ancient injury?
        |
        | Singing...

신택스 다이어그램::

    +------+-----------------------+
    | "| " | 행                    |
    +------| 연속 행               |
           +-----------------------+


블럭 인용
------------

독트리 요소: 블럭 인용, 어트리뷰션(attribution).

리터럴 블럭이나 다른 내용을 나타내는 마크업 없이 선행된 텍스트에 비해
들여쓰기 된 텍스트 블럭은 블럭 인용이라고 한다. 블럭 인용 안에서도 본문 요소와
인라인 마크업을 위한 모든 마크업은 계속 처리된다::

    이것은 블럭 인용을 설명하는, 일반적인 단락이다.

        "It is my business to know things.  That is my trade."

        -- Sherlock Holmes

블럭 인용은 어트리뷰션으로 끝날 수 있다: 블럭 인용에 맞춰 왼쪽 정렬된
"--", "---", 또는 엠 대쉬(em-dash)로 시작하는 텍스트 블럭을 어트리뷰션이라고
한다. 만약 어트리뷰션이 여러 행으로 구성되어 있다면, 두 번째와 이후의 행들은
모두 반드시 왼쪽 가장자리가 정렬되어 있어야 한다.

어트리뷰션으로 종료하면 여러 블럭 인용를 연속적으로 나타낼 수 있다.

    들여쓰여지지 않은 단락.

        블럭 인용 1.

        -- 어트리뷰션 1

        블럭 인용 2.

`빈 코멘트`_\ 는 블럭 인용을 흡수해버리는 선행 구조를
명시적으로 제거하기 위해 사용될 수 있다::

    * 리스트 항목.

    ..

        블럭 인용 3.

빈 코멘트는 블럭 인용을 분리시키는 데에도 사용할 수 있다::

        블럭 인용 4.

    ..

        블럭 인용 5.

블럭 인용 전후로 공백 행이 필요하지만 이 공백 행들은 블럭 인용
일부로 처리되지는 않는다.

신택스 다이어그램::

    +------------------------------+
    | (현재 들여쓰기                  |
    | 레벨)                         |
    +------------------------------+
       +---------------------------+
       | 블럭 인용              |
       | (본문 요소)+                |
       |                           |
       | -- 어트리뷰션 텍스트      |
       |    (선택적)                |
       +---------------------------+


독테스트 블럭
--------------

독트리 요소: 독테스트 블럭.

독테스트 블럭 독스트링(docstring)으로 복사 붙여넣기 된 대화형 Python 세션이다.
예시를 통해 사용법을 설명하고 파이썬 표준 라이브러리에 있는 `독테스트 모듈`_\ 을 통해서 우아하고 강력한 테스트 환경을 제공한다

독테스트 블럭는 파이썬 대화형 인터프리터의 메인 프롬프트인 ``">>> "`` 로
시작하는 텍스트 블럭이며, 공백 행으로 끝난다. 독테스트 블럭은 리터럴 블럭 신택스를
요구하지 않으면서 리터럴 블럭의 특수 케이스로 처리된다. 둘 다 존재하면,
리터럴 블럭 신택스가 독테스트 블럭 신택스보다 우선적으로 처리된다::

    이것은 일반적인 단락이다.

    >>> print 'this is a Doctest block'
    this is a Doctest block

    아래는 리터럴 블럭이다::

        >>> 이것은 reStructuredText에 의해 doctest block으로 인식되지
        않는지만 독테스트 모듈에 의해 인식되기는 한다.

독테스트 블럭는 들여쓰기를 요구하지 않는다.


테이블
------

독트리 요소: 테이블, tgroup, colspec, thead, tbody, row, entry.

ReStructuredText는 테이블 셀(cell)을 그리기 위한 두 가지 신택스를 제공한다:
`그리드 테이블`_, `단순 테이블`_.

다른 본문 요소와 마찬가지로, 테이블의 전후에는 공백 행이 필요하다.
테이블의 왼쪽 가장자리는 선행하는 텍스트 블럭의 가장자리에 맞춰 정렬 되여야 한다;
들여쓰기 되어있을 경우 테이블은 블럭 인용의 일부로 인식된다.

일단 분리되면, 각각의 테이블은 작은 문서로서 처리된다; 셀의 위쪽 및 아래쪽
경계는 공백 행의 기능을 한다. 각 셀은 0개 이상의 본문 요소를 포함하고 있다.
셀의 컨텐츠는 처리되기 전에 제거되는 양쪽의 여백을 포함할 수 있다.


그리드 테이블
``````````````

그리드 테이블 격자 모양의 "ASCII art"를 통해서 완전한 테이블 표현을
제공한다. 그리드 테이블는 임의의 셀 컨텐츠 (본문 요소)와 행, 열 병합을 모두
허용한다. 그러나 그리드 테이블은 간단한 데이터 세트를 제작하기에는 복잡하고
번거로울 수 있다. `이맥스 테이블 모드`_\ 는 그리드 테이블를 쉽게 편집할 수 있게
도와주는 이맥스(Emacs) 도구다. 제한이 있지만 간단한 표현은 `단순 테이블`_\ 을
참고하라.

그리드 테이블 "-", "=", "|", "+"로 만들어진 그리드로 표현된다.
하이픈("-")은 수평적으로 행을 나누기 위해 쓰인다. 등호("=")는
테이블 본문의 헤더 행을 테이블 본문과 분리시키기 위해 사용될 수 있다
(`이맥스 테이블 모드`_\ 에 의해 지원되지는 않는다). 수직 막대("|")는 열을
나누기 위해 사용된다. 플러스 기호("+")는 수직선과 수평선의 교차점을 표시하기
위해 사용된다. 예시::

    +------------------------+------------+----------+----------+
    | 헤더 행, 1 열            | 헤더 2      | 헤더 3   | 헤더 4     |
    | (헤더 행은 선택적이다)     |            |         |           |
    +========================+============+==========+==========+
    | 본문 1 행, 1 열          | 2 열       | 3 열      | 4 열     |
    +------------------------+------------+----------+----------+
    | 본문 2 행               | 셀은 열끼리 병합될 수 있다.            |
    +------------------------+------------+---------------------+
    | 본문 3 행               | 셀은 행끼    | - 테이블 셀은         |
    +------------------------+ 리 병합될    | - 본문 요소를         |
    | 본문 4 행               | 수 있다.     | - 포함한다.          |
    +------------------------+------------+---------------------+

셀 텍스트와의 원치 않는 상호작용을 피하기 위해서 주의해야 해야 한다.
예를 들면 아래 테이블의 2행은 2열부터 4열까지 병합되어 있다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열      | 3 열      | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행          |                                  |
    +--------------+----------+-----------+-----------+
    | 3 행          |          |           |           |
    +--------------+----------+-----------+-----------+

만약 수직 막대가 셀 안에서 사용되면, 실수로 열의 경계와 정렬되었을 때
의도하지 않게 영향을 줄 수도 있다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열     | 3 열       | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행         | Use the command ``ls | more``.   |
    +--------------+----------+-----------+-----------+
    | 3 행         |          |           |           |
    +--------------+----------+-----------+-----------+

여러 가지 해결책이 존재한다. 어떤 해결책이 되었든 셀의 정사각형
경계의 연속성을 끊어버리면 된다. 한 가지 가능한 방법은 수직 막대 앞에
스페이스를 추가해 텍스트를 이동시켜버리는 것이다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열     | 3 열       | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행         |  Use the command ``ls  | more``.  |
    +--------------+----------+-----------+-----------+
    | 3 행         |          |           |           |
    +--------------+----------+-----------+-----------+

다른 방법은 2행에 한 줄을 추가하는 것이다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열     | 3 열       | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행         | Use the command ``ls | more``.   |
    |              |                                  |
    +--------------+----------+-----------+-----------+
    | 3 행         |          |           |           |
    +--------------+----------+-----------+-----------+


단순 테이블
`````````````

단순 테이블은 쉽고 간단하다. 하지만 단순한 데이터 셋의 제한적인 행 기반 테이블
표현만을 제공한다. 대부분의 셀에서 임의의 본문 요소가 표현될 수는 있지만
셀의 내용은 일반적으로 한 단락이다. 단순 테이블은 다중 행(첫 번째 열 제외)과
열 병합이 가능하지만 행 병합은 불가능하다. 완전한 테이블 표현에 대해서는 위쪽의
`그리드 테이블`_\ 을 참고하라.

단순 테이블는 "="과 "-"로 만들어진 수평적인 경계로 표현된다.
등호("=")는 테이블의 위 아래 부분에 사용되고 테이블 본문과 테이블 헤더를
구분하기 위해 사용될 수도 있다. 하이픈("-")은 결합시킬 열에 밑줄을 표시해서
열의 병합을 나타내는 데 사용되고 명시적으로 행을 나누기 위해 선택적으로 사용
될 수도 있다.

단순 테이블은 상단에 등호와 열 경계를 구분하기 위한 하나 이상의
스페이스로 시작된다 (두 개 이상의 스페이스를 추천한다). 너비와 상관없이
위쪽 경계는 *반드시* 테이블의 모든 열을 표시해야 한다. 테이블에는
섹션 헤더와 구별하기 위해 최소 두 개 이상의 열이 있어야 한다. 위쪽 경계
다음에는 헤더 행이 올 것이고, 마지막 헤더 행의 아래에는 스페이스로 열이
구분된 '='로 이루어진 언더라인이 있다.
테이블의 하단 경계로 해석될 수 있기 때문에 헤더 행 구분 기호 아레에
공백 행은 없어야 한다. 테이블의 하단 경계는 '=' 밑줄과 열을 구분하는
스페이스로 구성된다. 예를 들어 아래의 진리 표(truth table)는 열 3개와
하나의 헤더 행, 본문 행 4개로 이루어져 있다::

    =====  =====  ======
      A      B    A and B
    =====  =====  ======
    False  False  False
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======

'-' 언더라인은 인접한 열을 합치기 위해 열의 경계를 "채우는" 방식으로 열의 병합을
나타내는 데 사용할 수 있다. 열 병합 언더라인은은 모든 열에 대하여 표시 되어야 하며
정해진 열의 경계에 맞춰서 정렬되어야 한다. 열 병합 언더라인을 포함하는 텍스트 줄은
다른 텍스트를 포함하면 안 된다. 열 병합 언더라인은 바로 위의 한 행에만 적용 된다.
아래는 헤더가 열 병합된 예시다::

    =====  =====  ======
       Inputs     Output
    ------------  ------
      A      B    A or B
    =====  =====  ======
    False  False  False
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======

각 텍스트 행은 열 병합이 되었을 경우를 제외하고는 열의 경계를 스페이스로
표시해야 한다. 첫 번째 열의 셀이 비어있을 때를 제외하고 각 텍스트 줄은 새로운
행으로 시작한다. 비어있을 경우 텍스트의 줄은 연속 행으로 파싱 된다.
이러한 이유로 인해서 (연속 행이 *아닌*) 새 행의 첫 번째 열에 있는 셀은
*반드시* 텍스트를 포함해야 한다; 빈 셀은 해석에 문제를 일으킬 수 있다
(아래의 팁을 참고하라). 또한 이 메커니즘은 첫 번째 열의 셀을 한 줄의 텍스트로
제한한다. 이러한 제한을 피하려면 `그리드 테이블`_\ 을 사용하라.

.. TIP::

   처리된 출력물에서 첫 번째 컬럼의 텍스트 없이 새 행을 시작하고 싶다면
   아래의 방법 중 하나를 사용하라:

   * 빈 코멘 ("..")는 처리된 출력에서 생략된다
     (아래의 코멘트_ 참고하라)

   * 백슬래쉬 이스케이프 ("``\``")된 스페이스를 사용하라 (위의 `이스케이핑 메커니즘`_\ 을 참고하라)

'-' 언더라인은 열 병합이 아닐 때도 사용할 수 있다. 이것은 특히 행이 여러 줄로
이루어진 긴 테이블에서 유용하다.

단순 테이블 내에서 공백 행은 사용 가능하다. 공백 행의 해석은
컨텍스트에 따라 다르다. 행 *사이에* 있는 공백 행은 무시된다.
여러 줄로 이루어진 행 *내부의* 공백 행은 셀 안에 있는 본문 요소나
단락을 나누어 준다.

가장 오른쪽 열은 경계가 없다; 텍스트는 테이블 경계로 표시되어진 테이블의
가장자리를 지나서 계속 이어질 수 있다. 그러나, 경계가 텍스트 전체를 포함할
수 있도록 충분히 길게 만드는 것을 추천한다.

아래의 예시는 연속행을 설명한다 (2행은 두 줄의 텍스트, 3행은 4줄의 텍스트로
이루어져 있다). 32 행열의 공백 행은 단락을 나누고, 텍스트는 테이블의 오른쪽
경계를 지나서 연장되어 있고, 4 행의 첫 번째 열은 처리 후 출력될 떄 비어있게
된다::

    =====  =====
    1  열  2 열
    =====  =====
    1      1행2열.
    2      2행2열.
           두 번째 단락.
    3      - 3행2열.

           - 3행2열의 글머리 기호
             리스트.
    \      4행 ; 1열은 비어있다.
    =====  =====


명시적 마크업 블럭
----------------------

명시적 마크업 블럭은 텍스트 블럭이다:

- ".."와 공백 문자로 시작한다("명시적 마크업 시작"),
- 두 번째 줄부터는 첫 번째 줄보다 들여쓰기 되어야 한다,
- 들여쓰기 되지 않은 줄 앞에서 끝난다.

명시적 마크업 블럭은 ".."를 글머리 기호로 사용하는 글머리 기호 리스트
항목과 비슷하다. 명시적 마크업 바로 다음에 오는 텍스트는 블럭 본문의
들여쓰기를 결정한다. 공통된 최대로 들여쓰기된 부분은 블럭 본문의 두 번째
줄부터 제거된다. 그러므로 첫 번째 구문이 한 라인에 있고 첫 번째 줄과
두 번째 줄의 들여쓰기가 달라야 한다면, 첫 번째 구문이 명시적 마크업과 같은
줄에서 시작하면 안된다.

명시적 마크업 블럭과 다른 요소 사이에는 공백 행이 삽입되어야 하며
명백한 명시적 마크업 블럭 사이에는 선택적으로 사용할 수 있다.

명시적 마크업 구문은, 각주, 인용, 하이퍼링크, 명령어, 대체 정의, 코멘트를
위해 사용된다.


각주
`````````

참조: `각주 참조`_.

독트리 요소: `각주(요소)`_ , 라벨_.

환경 설정:
`각주 레퍼런스 <각주 레퍼런스 세팅_>`_.

.. _각주(요소): ../doctree.html#footnote
.. _라벨: ../doctree.html#label
.. _각주 레퍼런스 세팅:
   ../../user/config.html#footnote-references-html4css1-writer

각각의 각주는 명시적 마크업 시작(".. ")와, 대괄호, 각주 라벨,
대활호, 공백문자, 들여쓰기된 본문 요소 순으로 구성되어 있다.
각주 라벨로는 아래의 것들을 사용할 수 있다:

- 한 개 이상의 십진수,

- 단일 "#"  (`자동 넘버링 각주`_),

- 간단한 참조 이름이 뒤에 오는 "#" (`자동 넘버링 레이블`_ ),
  또는

- 단일 "*" (`자동 심벌 각주`_ 참고).

각주 내용 (본문 요소)는 최소한 스페이스 3개 이상으로 들여쓰여져야 한다.
각주에 있는 첫 번째 본문 요소는 각주 라벨과 같은 줄에서 시작할 수 있다.
그러나 첫 번째 요소가 같은 줄에 있고 남아있는 요소의 들여쓰기가 다르다면
첫 번째 요소는 반드시 각주 라벨 다음 줄부터 시작해야 한다. 그렇지 않으면
들여쓰기의 차이가 인식되지 않을 것이다.


각주는 문서의 끝 뿐만 아니라 어디에서나 삽입될 수 있다. 출력물에서 어디에
어떻게 나타날지는 처리 시스템에 따라 다르다.

아래는 직접 번호를 매긴 각주의 예시이다::

    .. [1] 본문 요소는 이곳에 위치한다.

각각의 각주는 자동적으로 자기 자신을 가리키는 하이퍼링크 타겟을 생성한다.
하이퍼링크 타겟 이름은 각주 라벨과 같다. `자동 넘버링 각주`_\ 는
각주 라벨과 참조 이름으로 번호를 생성한다. 메커니즘에 대한 자세한 설명은
`암시적 하이퍼링크 타겟`_\  참고하라.

신택스 다이어그램::

    +-------+-------------------------+
    | ".. " | "[" 라벨 "]" 각주        |
    +-------+                         |
            | (본문 요소)+             |
            +-------------------------+


자동 넘버링 각주
.......................

번호 기호("#")는 각주와 각주 참조의 자동적 넘버링을 요청하는 각주 라벨의
첫 번재 문자로 사용될 수 있다.

수동으로 넘버링을 한 각주가 존재하지 않을 경우 자동 넘버링을 요청하는 첫 번째
각주는 라벨 "1"을 할당 받고 두 번재는 라벨 "2", 나머지도 순서대로 라벨을 할당
받는다 (아래 `수동 및 자동 넘버링 각주`_ 참고).
자동으로 라벨 "1"을 받은 각주는 라벨이 외부적으로(explicitly) 지정되는
것 처럼 "1"인 내부(implicit) 하이퍼링크 타겟을 생성한다.


.. _자동 넘버링 레이블: `자동 넘버 레이블`_

각주는 자동 넘버링 ``[#label]`` 을 요청하는 동시에 외부적으로 라벨을
지정할 수 있다. 이 라벨은 _`자동 넘버 레이블`\이라고 불린다.
자동 넘버 레이블은 두 가지 일을 한다:

- 각주 자신에 대해서 이름이 자동 넘버링 레이블인 ("#"를 포함하지 않음) 하이퍼 링크
  타겟을 생성한다.

- 또한 각주 참조나 하이퍼링크 참조로서, 자동 넘버링 된 각주가
  여러번 참조되는 것을 허용한다::

      만약 [#note]_ 가 첫 번째 각주 참조라면, "[1]"로 나타날 것이다.
      우리는 이것을 다시 [#note]_ 로 참조할 수 있고 "[1]"로 보일 것이다.
      또한 우리는 note_ 로 참조할 수 있다 (일반 내부 하이퍼링크 참조).

      .. [#note] 이 것은 "note"로 레이블된 각주이다.

넘버링은 참조의 순서가 아니라 각주의 순서에 따라 결졍된다. 자동 숫자 라벨
(``[#]_``) 각주 참조의 경우, 각주와 각주 참조가 같은 순서로 되어 있어야
하지만 정확히(in lock-step) 번갈아(alternate) 나올 필요는 없다::

    [#]_ 는 각주 1에 대한 참조 번호, [#]_ 는 각주 2에 대한 참조 번호다.

    .. [#] 이건 각주 1.
    .. [#] 각주 2.
    .. [#] 각주 3 이다.

    [#]_ 는 각주 3에 대한 참조 번호다.

각주가 자동 넘버링 된 각주 참조 번호이거나 여러 참조 번호가 굉장히 근접해 있을
경우 특별한 주의가 필요하다. 각주와 참조 번호는 문서에서 등장하는 순서에 따라
기록되며 사람이 읽어야 하는 순서와 같을 필요는 없다.


자동 심벌 각주
.....................

별표("*")는 각주와 각주 참조를 위한 자동 심벌(symbol)을 생성을 요청하는 각주 라벨로
사용될 수 있다. 라벨에 다른 문자 없이 별표만 쓸 수도 있다::

    다음은 심벌 각주 참조: [*]_.

    .. [*] 이것이 각주다.

심벌은 대응하는 각주와 각주 참조에 라벨로 삽입될 것이다. 참조의 번호는
각주의 번호와 같다. 심벌 각주는 여러 참조를 가질 수 없다.

기본 Docutils 시스템은 각주 표시를 위해 아래의 심벌을 제공한다 [#]_:

- asterisk/star ("*")
- dagger (HTML character entity "&dagger;", Unicode U+02020)
- double dagger ("&Dagger;"/U+02021)
- section mark ("&sect;"/U+000A7)
- pilcrow or paragraph mark ("&para;"/U+000B6)
- number sign ("#")
- spade suit ("&spades;"/U+02660)
- heart suit ("&hearts;"/U+02665)
- diamond suit ("&diams;"/U+02666)
- club suit ("&clubs;"/U+02663)

.. [#] 이것은 The Chicago Manual of Style, 14th edition, section 12.51의
   "Note Reference Marks"에 있는 기호 리스트에서 영감을 받은 리스트다.
   CMoS에서는 pilcorw 대신에 "Parallels" ("||")이 제공되었다.
   마지막 4개의 기호(카드 무늬)는 임의로 추가 되었다.

10 개 이상의 기호가 필요하다면 동일한 순서로, 예를 들어 기호를 두 배("**"), 세 배 해서
재사용할 수 있다.

.. Note:: 자동 심벌 각주를 사용할 때, 출력 인코딩 방식을 선택하는 것은
   중요하다. 많은 기호가 Latin-1 (ISO 8859-1) 같은 특정한 특정한 인코딩 방식에서
   제대로 지원되지 않는다. 출력 인코딩 방식을 위해 UTF-8을 사용하는 것을 추천한다.
   HTML과 XML 출력을 위한 대안으로는 "xmlcharrefreplace"을 사용하라.
   `output encoding error handler`__ 참고.

__ ../../user/config.html#output-encoding-error-handler


수동 및 자동 넘버링 각주
........................................

결과를 제대로 예측할 수는 없지만 수동 및 자동 각주 넘버링은 한 문서에서
동시에 사용될 수 있다. 수동 넘버링이 우선순위가 높다. 사용되지 않은
각주 번호만이 자동 넘버링 각주에 할당된다. 아래의 예시를 확인하라::

    [2]_ 는 수동으로 넘버링된 "2"가 되고,
    [#]_ 는 자동으로 넘버링 된 "3"이 되고,
    [#label]_ 는 라벨이 자동으로 넘버링 된 "1"이 된다.

    .. [2] 이 각주는 수동으로 넘버링 되었기 때문에 숫자가 고정된다.

    .. [#label] 이 자동으로 숫자 라벨링 된 각주는 "1"로 라벨링 된다.
       이것은 처음으로 자동 넘버링된 각주고 라벨 "1"인 다른 각주는 존재하지
       않는다. 각주 참조의 순서가 아니라 각주의 순서가 넘버링을 결정한다.

    .. [#] 이 각주는 "3"으로 라벨링 될 것이다. 이 각주는 두 번째로
       자동 넘버링 된 각주지만 라벨 "2"는 이미 사용되었다.


인용
`````````

참고: `인용 참조`_.

독트리 요소: `인용(요소)`_

.. _인용(요소): ../doctree.html#citation

인용은 ``[note]`` 나 ``[GVR2001]`` 같이 숫자가 아닌 라벨만 사용한다는 점을
제외하고는 각주와 동일하다. 인용 라벨은 단순한 `참조 이름`_ 이다
(공백 없이 대소문자를 구분하지 않은 문자, 숫자, 하이픈, 언더스코어, 구두점으로
이루어져있다. 인용은 각주와 달리 따로 렌더링 된다::

    이것은 인용 참조다: [CIT2002]_.

    .. [CIT2002] 이것은 인용이고 라벨이 문자인 것을 제외하면 각주와
       같다.


.. _하이퍼링크:

하이퍼링크 타겟
`````````````````

독트리 요소: 타겟_.

.. _타겟: ../doctree.html#target

이것은 아래에 정의된 `암시적 하이퍼링크 타겟`_\ 과 구별하기 위해
_`명시적 하이퍼링크 타겟`\ 이라고도 불린다.

하이퍼링크 타겟은 `하이퍼링크 참조`_\ 에 의해
연결된 문서의 외부 혹은 내부의 위치를 식별한다.

하이퍼링크 타겟은 이름이 있거나 익명으로 처리될 수 있다.
이름이 있는 하이퍼링크 타겟은 명시적 마크업 시작 (".. ") 으로 시작되고
언더스코어, 참조 이름, 콜론, 공백, 링크 블럭으로 이어진다::

    .. _하이퍼링크-이름: 링크-블럭

참조 이름은 대소문자를 구분하지 않고 공백 문자가 무효화 된다. 자세한 사항과
예시는 `참조 이름`_\ 을 참고하라.

익명 하이퍼링크 타겟은 명시적 마크업 시작 (".. ")와 언더스코어 두 개,
콜론, 콩백, 링크 블럭으로 이루어져 있으며 참조 이름은 없다::

    .. __: 익명-하이퍼링크-타겟-링크-블럭

익명 하이퍼링크의 대체 구문은 언더스코어 두 개, 스페이스, 링크 블럭으로
이루어져있다::

    __ 익명-하이퍼링크-타겟-링크-블럭

아래의 `익명 하이퍼링크`_\ 를 참고하라.

하이퍼링크 타겟은 세 종류가 있다: 내부, 외부, 우회.

1. _`내부 하이퍼링크 타겟` 는 빈 링크 블럭을 가지고 있다. 이 타겟은
   하이퍼링크를 한 지점에서 문서 내의 다른 지점으로 연결해주는 목적지를 제공한다.
   내부 하이퍼링크 타겟은 타겟을 따르는 요소를 가리킨다. [#]_ 예시::

       이 내부 하이퍼링크를 클릭하면 아래에 있는 target_ 으로 데려다 준다.

       .. _target:

       위에 있는 하이퍼 링크 타겟은 이 단락을 가리킨다.

   내부 하이퍼링크 타겟은 "연결(chiained)"될 수 있다. 다수의 인접한
   내부 하이퍼링크 타겟은 같은 요소를 가리킨다::

       .. _target1:
       .. _target2:

       타겟 "target1"과 "target2"는 같다; 두 타겟은 모두 이
       단락을 가리킨다.

   가리켜지는 요소가 링크 블럭이 URI로 된 (아래의 #2를 참고)
   외부 하이퍼링크 타겟이라면 외부 하이퍼링크 타겟의
   URI는 내부 하이퍼링크 타겟으로 전파된다; 전부 같은 URI를
   가리키게 된다. URI를 복사할 필요가 없다. 예를 들어, 아래의 3개의
   하이퍼링크 타겟은 같은 URI를 참조한다::

       .. _Python DOC-SIG 메일 리스트 아카이브:
       .. _archive:
       .. _Doc-SIG: http://mail.python.org/pipermail/doc-sig/

   인라인 형태의 내부 하이퍼링크 타겟도 사용할 수 있다;
   `인라인 내부 타겟`_\ 을 참고하라.

   .. [#] 내부 하이퍼링크 타겟이 들여쓰기 된 텍스트 블럭의 끝에
      내포되어 있어도 사용할 수 있다. 이 작업을 통해서 타겟을 개별 리스트
      항목으로 설정할 수 있다 (선행하는 내부 대상이 리스트 전체에 적용되기 때문에
      첫 번째는 제외)::

       * 글머리 기호 리스트

         .. _`두 번째 항목`:

       * 하이퍼링크 타겟이 있는 두 번째 항목.


2. _`외부 하이퍼링크 타겟`\ 은 링크 블럭이 절대 또는 상대 URI나
   이메일 주소다. 예를 들면, 아래처럼 입력을 받는다::

       See the Python_ home page for info.

       `Write to me`_ with your questions.

       .. _Python: http://www.python.org
       .. _Write to me: jdoe@example.com

   HTML로 처리된 이후, 하이퍼링크는 아래처럼 표시된다::

       See the <a href="http://www.python.org">Python</a> home page
       for info.

       <a href="mailto:jdoe@example.com">Write to me</a> with your
       questions.

   외부 하이퍼링크의 URI는 명시적 마크업 시작과 타겟 이름이
   있는 같은 줄 또는 공백 행 없이 바로 다음에 들여쓰기 된 블럭으로 시작할
   수 있다. 링크 블럭이 여러 줄일 경우 블럭 내에서는 서로 이어진다.
   이스케이프 되지 않은 공백문자는 제거된다 (줄을 바꾸기 위한 공백만 허용이
   된다). 아래의 외부 하이퍼링크 타겟은 모두 동일하다::

       .. _one-liner: http://docutils.sourceforge.net/rst.html

       .. _starts-on-this-line: http://
          docutils.sourceforge.net/rst.html

       .. _entirely-below:
          http://docutils.
          sourceforge.net/rst.html

   이스케이프 된 공백 문자는, 의도적인 스페이스로 보존된다::

       .. _reference: ../local\ path\ with\ spaces.html

   외부 하이퍼링크 타겟의 URI가 마지막 문자로 언더스코어를 취하면
   우회 하이퍼링크 타겟으로 잘못 처리될 가능성이 있기 때문에 이스케이프
   되어야 한다::

       이 link_ 는 ``underscore_`` 라는 파일을 가리킨다.

       .. _link: underscore\_

   일반적으로 추천되지는 않지만 하이퍼링크 참조 안에서 URI를 직접 포함시키는
   것은 가능하다. 아래의 `임베디드 URI와 에일리어스`_\ 를 참고하라.


3. _`간접 하이퍼링크 타겟`\ 는 링크 블럭에 하이퍼링크 참조를 가지고 있다.
   아래의 예시에서 타겟 "one" 간접적으로 타겟 "two"가 참조하는 것을
   참조하고 타겟 "two"는 타겟 "three"가 참조하는 내부 하이퍼링크 타겟을
   참조한다. 결과적으로 세 개의 참조는 모두 같은 것을 가리킨다::

       .. _one: two_
       .. _two: three_
       .. _three:

   문서의 다른 곳에 있는 `하이퍼링크 참조`_\ 처럼, 구문 참조
   (phrase-reference)가 링크 블럭에서 사용된다면 반드시 백 쿼트로 둘러싸여야 한다.
   `외부 하이퍼링크 타겟`_\ 처럼, 간접 하이퍼링크 타겟의 링크
   블럭은 명시적 마크업 시작이 있는 같은 줄이나 다음 줄에서 시작할
   수 있다. 링크 블럭은 여러 줄로 분리될 수도 있으며 이 경우에는 정규화 되기 전에
   공백 문자로 연결된다.

   예를 들면, 아래의 간접 하이퍼링크 타겟은 모두 동일하다::

       .. _one-liner: `A HYPERLINK`_
       .. _entirely-below:
          `a    hyperlink`_
       .. _split: `A
          Hyperlink`_

   하이퍼링크 참조에 에일리어스(alias)를 직접 포함시키는 것도 가능하다.
   아래의 `임베디드 URI와 에일리어스`_\ 를 참고하라.

그리고 참조 이름이 콜론을 포함하고 있다면:

- 구문은 반드시 백 쿼트로 싸여야 한다::

      .. _`FAQTS: Computers: Programming: Languages: Python`:
         http://python.faqts.com/

- 링크 타켓에서 백 슬래쉬로 이스케이프 되어야 한다::

      .. _Chapter One\: "Tadpole Days":

      It's not easy being green...

중복 참조 이름의 해결을 위해서는 아래의 `암시적 하이퍼링크 타겟`_\ 을
참고하라.

신택스 다이어그램::

    +-------+----------------------+
    | ".. " | "_" 이름 ":" 링크     |
    +-------+ 블럭                 |
            |                      |
            +----------------------+


익명 하이퍼링크
....................

`World Wide Web Consortium`_\ 는 `HTML Techniques for Web Content
Accessibility Guidelines`_\ 에서 작성자가 각 링크에 대한 타켓을 명확하게 구분해놓을
것을 권장했다. 하이퍼링크 참조는 가능한 길어야 하지만 긴 하이퍼링크 이름을 타겟에
복제하는 것은 어렵고 에러를 일으키기 쉽다. 익명(Anonymous) 하이퍼링크는 장황한
하이퍼링크 참조를 편리하게 하도록 설계되었으며 `자동 넘버링 각주`_\
와 유사하다. 이것들은 특히 짧거나 하나로 구성된 문서에 유용하다. 그러나
이 장점은 쉽게 남용 되어서 텍스트를 읽을 수 없게 만들거나 문서를 보존할 수 없게
만든다. 사용할 때 주의할 필요가 있다.

익명 `하이퍼링크 참조`_\ 는 하나가 아닌 두 언더스코어로 지정된다::

    `the web site of my favorite programming language`__.

익명 타겟은 ".. __:"로 시작하고; 참조 이름은 허용되지 않는다::

    .. __: http://www.python.org

더 쉽게 익명 타겟은 "__"만으로 시작할 수 있다::

    __ http://www.python.org

참조의 참조 이름은 참조와 참조 타겟의 이름과 매치되도록 사용되지 않는다.
대신에 문서에 있는 익명 하이퍼링크 참조의 순서와 타겟이 중요하다:
첫 번째 익명 참조는 첫 번째 익명 타겟과 연결된다. 문서의 익명 하이퍼링크 참조
갯수는 익명 타겟의 수와 같아야 된다. 가독성을 위해서 타겟이 참조와 가깝게 있도록
쓸 것을 추천한다. 익명 참조를 포함하는 텍스트를 편집할 때는 주의해야 한다:
참조를 재배열하거나 제거, 추가하는 경우에는 대응하는 타겟의 순서를 확인해야 한다.


명령어
``````````

독트리 요소: 명령어에 따라서 결정.

명령어(Directives)는 reStructuredText를 위한 확장 매커니즘으로
새로운 기본(primary) 신택스 추가 없이 새로운 구조에 대한 지원을 제공한다.
(명렁어는 지역적으로 추가적인 신택스를 지원할 수 있다). (reStructuredText
파서 레퍼런스에 등록되고 구현되어 있는) 모든 기본 명령어는 `reStructuredText
Directives`_ 문서에서 설명이 되어 있고, 언제든지 참고 가능하다.
명령어는 도메인에 따라 다르기 때문에, 문서를 처리할 때 사용하기 위해서는
특별한 조치가 필요할 수 있다.

예를 들어, 아래는 image_\ 를 삽입할 수 있는 방식이다::

    .. image:: mylogo.jpeg

figure_\  (캡션이 달린 그래프)는 이런 식으로 삽입한다::

    .. figure:: larch.png

       The larch.

admonition_\  (주석, 경고 등)은 다른 본문 요소를 포함한다::

    .. note:: 이것은 한 단락이다.

       - 여기에 글머리 기호 리스트가 위치한다.

명령어는 명시적 마크업 시작 (".. ")과 명렁어 타입, 콜론 두 개
공백 문자로 표시되며 다 합쳐서 "명령어 마커"라고 부른다.
명령어 타입은 대소문자를 구분하지 않는 한 단어로 (공백 없이 문자, 숫자, 하이픈,
언더스코어 기호, 콜론, 마침표로 구성) 이루어져 있다. 명령어 타입 다음에는
아래와 같은 이유 때문에 콜론을 두 개 써준다.

- 일반적인 텍스트에서 쓰이는 것과 달리 콜론 두 개는 구분되기 쉽다.

- 콜론 두 개는 아래와 같은 일반적인 코맨트 텍스트와 충돌을 일으키지 않는다::

      .. Danger: modify at your own risk!

- reStructuredText를 실행했을 때 명령어를 인식하지 못하면 (directive-handler가
  설치되어 있지 않으면), level-3 (error) 시스템 메세지가 발생할 것이다.
  그리고 명령어를 포함한 전체 명령어 블럭이 literal block에 포함될 것이다.
  따라서 "::"가 당연히 선택된 것이다.

명령어 블럭은 명령어 마커 다음부터 시작되며 이후에는 들여쓰기된 텍스트
가 이어진다. 명령어 마커의 해석은 명령어 코드에 달려있다.
명령어 블럭에는 세가지 논리 파트가 있다:

1. 명령어 인수(Directive arguments).
2. 명령어 옵션(Directive options).
3. 명령어 내용(Directive contents).

각각의 명령어는 이 파트를 조합해서 사용할 수 있다. 명령어 인수는
파일 시스팀 경로(path), URL, 제목 텍스트 등이 올 수 있다. 명령어 옵션은
`필드 리스트`_\ 를 써서 표시된다; 필드 이름과 컨텐츠는 명령어에 한정되어 있다.
인수와 옵션은 명령어의 첫 번째나 두 번째 줄에서 시작하는 연속 블럭이
되어야 한다; 공백 행은 명령어 내용 블럭의 시작을 의미한다.
만약 인수나 옵션이 명령어에 의해 사용되면, 반드시 공백 행으로
명령어 내용과 분리시켜야 한다. "figure"는 세 파트를 모두 사용한다::

    .. figure:: larch.png
       :scale: 50

       The larch.

단순한 명령어는 내용이 필요하지 않다. 내용 블럭을 사용하지 않는
명령어 다음에 들여쓰기된 텍스트가 오게 되면 에러가 발생한다.
만약 명령어 바로 다음에 블럭 인용이 와야 하는 경우 사이에 빈 코멘트를
사용하라 (아래의 코멘트_ 참고).

명령어로 인해 취해진 작동과 명령어 내용 블럭 또는
후속 텍스트 블럭에 있는 텍스트의 해석은 명령어에 의존한다.
자세한 내용은 `reStructuredText Directives`_\ 를 참고하라.

명령어는 내용의 임의적인 처리를 위한 것이기 때문에 원본 텍스트와는 관련이 없는
것을 변형시킬 수도 있다. 명령어는 대체 신택스를 시험하는 것처럼
파서의 작동을 수정하기 위한 프라그마(pragma)로 사용될 수 있다.
현재는 이 기능을 위한 파서 지원은 없다; 프라그마 명령어를 위한 타당한 필요성이
발견되면 추후에 지원될 수도 있다.

명령어는 "명령어" 요소를 생성하지는 않는다; 이것은 단지
*파서 구조* 일 뿐이며 reStructuredText 외부에서는 본질적인 의미가 없다.
대신 파서는 인식된 명령어를 (특수한) 문서 요소로 변형한다. 알 수 없는
명령어는 level-3 (에러) 시스템 메세지를 발생시킨다.

신택스 다이어그램::

    +-------+-------------------------------+
    | ".. " | 명령어 타입 "::" 명령어           |
    +-------+ 블럭                           |
            |                               |
            +-------------------------------+


대체 정의
````````````````````````

독트리 요소: 대체 정의(substitution_definition).

대체 정의는 명시적 마크업 시작 (".. ")과, 수직 막대, 대체 텍스트,
수직 막대, 공백문자, 정의 블럭으로 구성되어 있다. 대체 텍스트는
공백 문자로 시작하고 끝날 필요는 없다. 대체 정의 블럭은 (앞에 ".." 없이)
"image_"나 "replace_" 같이 임베딩 된 인라인 호환 명령어를 포함할 수 있다::

    |biohazard| 기호는 의료 폐기물을 버리는 컨테이너에 쓰여야 한다.

    .. |biohazard| image:: biohazard.png

대체 정의 블럭이 직접적 혹은 간접적으로 순환 대체 참조를 포함하고 있을 경우
에러가 발생한다.

`대체 참조`_\ 는 (대체 텍스트를 매칭해서 연결된) 대응되는 정의의
처리된 컨텐츠로 라인 안에서 대체된다. 매칭은 대소문자를 구별해서 이루어지지만
정확히 매치되는 것이 없는 경우 대소문자구분 없이 이루어진다.

대체 정의는 블럭 수준의 명령어_\ 가 인라인 텍스트로 공유되는 것을 허용한다.
세부적인 부분을 텍스트의 플로우(flow)로부터 영향을 받지 않게 하면서 텍스트에 있는 복잡한
인라인 구조를 임의로 포함시키는 방식으로 이루어진다. 그것들은 SGML/XML의 지정된
엔티티(entity)와 프로그래밍 언어 매크로(macro)와 같다.

대체 메커니즘 없이 특수한 용도의 인라인 구조를 원한다면 신택스 변경에 대해
청원해야(petition) 한다. 현재 사용되는 명령어 신택스와 결합한 인라인 구조는
(새로운 명령어를 제외하고) 새로운 신택스 없이 코딩될 수 있다.

신택스 다이어그램::

    +-------+-----------------------------------------------------+
    | ".. " | "|" 대체 텍스트 "| " 명령어 타입 "::" 데이터              |
    +-------+ 명령어 블럭                                           |
            |                                                     |
            +-----------------------------------------------------+

아래는 대체 메커니즘에 대한 사용 사례이다. 임베딩된 명령어의 대부분은
예시일 뿐 실제로 구현된 상태는 아니라는 사실을 명심하라.


객체
    대체 참조는 지정되지 않은 텍스트와 고유 객체 식별자(unique object identifier)
    를 결합킬 때 사용할 수 있다.

    예를 들어, 많은 사이트들은 인라인 "사용자" 명령어를 구현하기를 원한다::

        |Michael| and |Jon| are our widget-wranglers.

        .. |Michael| user:: mjones
        .. |Jon|     user:: jhl

    사이트의 필요에 따라, 이 것은 검색을 위해 문서를 인덱싱 하거나
    인라인 텍스트를 다양한 방식으로 (메일투(mailto), 홈페이지,
    프로파일과 연락처 정보가 있는 자바스크립트 마우스오버(mouseover) 등)
    하이퍼링크 하거나, 텍스트 표현을 커스터마이징 (유저 이름을 인라인 텍스트에
    포함시키거나, 링크가 있는 아이콘 이미지를 텍스트 다음에 포함시키거나,
    텍스트를 굵게 또는 다른 색으로 만드는 등) 할 때 사용될 수 있다.

    모호한 명칭이지만 고유 식별자가 있는 특정한 객체를 자주 참조하는
    문서에도 같은 접근 방식이 사용될 수 있다. 영화, 앨범, 책, 사진
    소송 사건, 법 등이 가능하다::

        |The Transparent Society| 개인정보 이슈에 대한 매력적인
        대안을 제시한다.

        .. |The Transparent Society| book:: isbn=0738201448

    문맥에서 모듈이나 클래스 이름이 명확하지 않고 해석된 텍스트가 사용될 수
    없는 클래스나 함수는 해석된 텍스트는 다른 가능성이 있다::

        4XSLT 는 편리한 |runString| 메서드를 가지고 있다, 따라서
        변형된 출력을 원하는 것 뿐이라면 DOM 객체를 사용할
        필요가 없다.

        .. |runString| function:: module=xml.xslt class=Processor

이미지
    대체 참조의 가장 일반적인 용도는 이미지다::

        West led the |H| 3, covered by dummy's |H| Q, East's |H| K,
        and trumped in hand with the |S| 2.

        .. |H| image:: /images/heart.png
           :height: 11
           :width: 11
        .. |S| image:: /images/spade.png
           :height: 11
           :width: 11

        * |Red light| means stop.
        * |Green light| means go.
        * |Yellow light| means go really fast.

        .. |Red light|    image:: red_light.png
        .. |Green light|  image:: green_light.png
        .. |Yellow light| image:: yellow_light.png

        |-><-| is the official symbol of POEE_.

        .. |-><-| image:: discord.png
        .. _POEE: http://www.poee.org/

    "image_" 명령어는 구현되어 있다.

스타일 [#]_
    대체 참조는 인라인 텍스트와 외부적으로 정의된 표현 스타일을
    결합시키기 위해 사용될 수 있다::

        심지어 |the text in Texas| 은 크다.

        .. |the text in Texas| style:: big

    스타일의 이름은 특정한 출력 형식의 컨텍스트에서는 유의미하지만 (HTML 출력을
    위한 CSS 클래스 이름, LaTeX 을 위한 LaTex 스타일 이름 등), 일반 텍스트 같은
    다른 출력 포멧에서는 무시될 수 있다.

    .. @@@ 이것은 다시 생각하고 작성하거나 제거되어야 한다:

       해석된 텍스트는 이 목적으로 적합하지는 않다. 왜냐하면 스타일 이름의
       집합이 미리 정의될 수 없기 때문이다. 이것은 파서나 출력 포맷터 제작자
       의 영역이 아니라 컨텐츠 작성자의 영역이다. 그리고 스타일 이름
       인수와 해석된 텍스트 스타일 기능을 결합시킬 방법은 없다.
       또한 스타일링 블럭에 같은 메커니즘을 사용하는 것이 더 바람직하다::

           .. style:: motto
              At Bob's Underwear Shop, we'll do anything to get in
              your pants.

           .. style:: disclaimer
              All rights reversed.  Reprint what you like.

    .. [#] 해석된 텍스트 기능 신택스의 확장 같은 더 간단한 신택스를 보장하는 스타일
       메커니즘에 대한 필요는 충분히 있다. 대체 메커니즘은 간단한 텍스트 스타일링에는
       복잡한 방식이다.

템플릿
    인라인 마크업은 템플릿 엔진에 의해 추후에 처리되기 위해 사용될 수 있다.
    예를 들어 Zope_ 작성자는 이렇게 쓸 수 있다::

        Welcome back, |name|!

        .. |name| tal:: replace user/getUserName

    처리 후에, 이 ZPT 출력은 아래와 같이 나올 것이다::

        Welcome back,
        <span tal:replace="user/getUserName">name</span>!

    Zope는 다음에 세션에서 이것을 "Welcome back, David!"처럼 실제
    사용자로 변경할 것이다.

대체 텍스트
    대체 매커니즘은 간단한 매크로 대체을 위해서 사용될 수 있다.
    하나 이상의 문서에서 대체 텍스트가 반복될 때, 특히 나중에 바뀌어야
    될 필요가 있을 때 유용하다. 간단한 예시가 불가피하게 고안 되었다::

        |RST|_ 는 특히 |RST| 에 대해 쓸 때 계속 타이핑 하는 것을
        신경쓰이게 만든다. 그리고 매번 bicapitalized 단어를 설명하는
        것은 |RST| 소스 가독성을 위해서 꼭 필요하지 않다.

        .. |RST| replace:: reStructuredText
        .. _RST: http://docutils.sourceforge.net/rst.html

    대체 참조를 처음 사용할 때 언더스코어를 쓰는 것에 주의하라. 이것은
    대응하는 하이퍼링크 타겟에 대한 참조를 표시해준다.

    대체는 또한 대체 텍스트가 다른 인라인 구조를 사용해서 표현될 수 없을 때나
    지나치게 길 때 유용하다::

        하지만 |j2ee-cas|__ 같은 이름에 비하면 아무것도 아니다.

        .. |j2ee-cas| replace::
           the Java `TM`:super: 2 Platform, Enterprise Edition Client
           Access Services
        __ http://developer.java.sun.com/developer/earlyAccess/
           j2eecas/

    "replace_" 명령어는 구현되어 있다.


코멘트
````````

독트리 요소: 코멘트(comment).

명시적 마크업 시작 뒤에 오는 임의의 들여쓰기된 텍스트는 코멘트 요소로
처리될 것이다. 코멘트 블럭의 텍스트에는 추가적인 처리가 이루어지지 않는다;
코멘트는 하나의 텍스트 블롭(blob)을 포함하고 있다. 출력 포맷터에
따라 코멘트는 처리된 결과물에서 제거될 수 있다. 코멘트에 대한 단 하나의 제한
사항은 코멘트는 다른 명시적 마크업 구조(대체 정의, 명령어, 각주, 인용,
하이퍼링크 타겟)와 같은 구문을 사용하지 않는다는 점이다. 다른 명시적 마크업
구조로 인식되지 않도록 하려면 ".."만 따로 한 행에 남겨두면 된다::

    .. This is a comment
    ..
       _so: is this!
    ..
       [and] this!
    ..
       this:: too!
    ..
       |even| this:: !

.. _빈 코멘트:

명시적 마크업 시작 다음에 아무것도 없이(공백 문자 제외) 공백 행만 오면
"빈 코멘트"가 된다. 이것은 선행하는 구조를 종료하기 위해 사용되며
다음에 오는 들여쓰기된 텍스트를 흡수해버리지 않는다. 리스트나 다른 들여쓰기된
구조 다음에 블럭 인용을 쓰기 위해서는 사이에 들여쓰기 되지 않은 빈 코멘트를
삽입하라.

신택스 다이어그램::

    +-------+----------------------+
    | ".. " | 코멘트                |
    +-------+ 블럭                  |
            |                      |
            +----------------------+


암시적 하이퍼링크 타겟
==========================

암시적(Implicit) 하이퍼링크 타겟은 섹션 제목, 각주, 인용으로 생성되며
확장 구조에 의해서 생성될 수도 있다. 암시적 하이퍼링크 타겟은
명시적 `하이퍼링크 타겟`_\ 과 동일하게 작동한다.

중복된 암시적(implicit), 명시적 참조 이름 충돌로 인한 모호성 문제는
아래의 절차에 의해 방지된다:

1. `명시적 하이퍼링크 타겟`_\ 은 같은 참조 이름을 가진 암시적 타겟보다
   우선한다. 이때 암시적 하이퍼링크 타겟은 제거되고 level-1 (info) 시스템
   메세지가 삽입된다.

2. 중복된 암시적 하이퍼링크 타겟은 제거되고 level-1 (info)
   시스템 메세지가 삽입된다. 예를 들어, 엄격하게 구조화된(rigidly-structured)
   문서의 하위 "도입부" 섹션 같이 둘 이상의 섹션이 같은 제목을 가지고 있으면
   중복된 하이퍼링크 타겟이 생길 것이다.

3. 중복된 명시적 하이퍼링크 타겟은 제거되고 level-2 (warning) 시스템 메세지가
   삽입된다. 예외: (하이퍼링크 타겟과 참조 URI이 동일한) 중복된 `명시적 하이퍼링크 타겟`_\
   은 충돌을 일으키지 않고 제거되지도 않는다.

시스템 메세지는 타겟 링크가 제거된 자리에 삽입된다. `PEP 258`_\ 의
"에러 처리(Error Handling)" 부분을 참고하라 .

파서는 반드시 "고유한(unique)" 하이퍼 링크 세트를 반환해야 한다. Docutils_\ 같은
호출 소프트웨어는 분석할 수 없는 링크에 대해서 경고 메세지와 원인을 출력한다.


인라인 마크업
=============

reStructuredText에서 인라인 마크업은 텍스트 블럭 안에 있는 단어나 구에
적용된다. 텍스트에서 단어를 구분하기위해 사용되는 공백문자와 구두점은
인라인 마크업 신택스 구조를 구분하기 위해 똑같이 사용된다 (자세한 내용은
`인라인 마크업 인식 규정`_\ 을 참고하라). 인라인 마크업 안에 있는
텍스트는 공백 문자로 시작하고 끝나지 않아도 된다. 권장되지는 않지만 임의의
`문자 수준의 인라인 마크업`_\ 이 지원된다. 인라인 마크업은 내포될
수 없다.

인라인 마크업 구조는 9개가 존재한다. 그중 다섯 개는 마크업을 표시하기 위해서
동일한 시작 스트링과 종료 스트링을 사용한다:

- 강조_: "*"
- `강한 강조`_: "**"
- `해석된 텍스트`_: "`"
- `인라인 리터럴`_: "``"
- `대체 참조`_: "|"

3개의 구조는 다른 시작 스트링과 끝 스트링을 사용한다:

- `인라인 내부 타겟`_: "_`" and "`"
- `각주 참조`_: "[" and "]_"
- `하이퍼링크 참조`_: "`" and "\`_" (phrases), or just a
  trailing "_" (single words)

`자립 하이퍼링크`_ 는 내부적으로 인식되고, 추가적인 마크업을
사용하지 않는다.

인라인 마크업 인식 규정
-------------------------------

인라인 마크업 시작 스트링과 끝 스트링은 아래의 조건이 충족되었을 때만
인식된다:

1. 인라인 마크업 시작 스트링 바로 다음에 공백 문자가 오지 않는다.

2. 인라인 마크업 종료 스트링 바로 앞에 공백 문자가 오지 않는다.

3. 인라인 마크업 시작 스트링과 종료 스트링 사이에는 최소한 한 문자가 포함되어야
   한다.

4. 인라인 마크업 시작 스트링과 종료 스트링 앞에는 `인라인 리터럴`_\ 의 종료 스트링을
   제외하고 이스케이프 되지 않은 백슬래쉬가 오면 안 된다. 자세한 내용은
   `이스케이핑 메커니즘`_\ 을 참고하라.

5. 인라인 마크업 시작 스트링 바로 앞에 ASCII 문자 ``' " < ( [ {`` 나 유사한
   non-ASCII 문자 [#openers]_ 가 오고 바로 뒤에 ``' " ) ] } >`` 또는
   non-ASCII 문자 [#closers]_ 가 올 수 없다. 따옴표의 경우 `quotation
   marks in international usage`_\ 에서 일치하는 문자일 수 있다.

`단순 인라인 마크업`_ 설정이 False로 되어 있으면 (디폴트), 인라인 마크업
주위에 오는 문자에 대해 추가적인 조건이 적용될 수 있다:

6. 인라인 마크업 시작 스트링은 텍스트 블럭을 시작하거나 아래의 문자 바로 뒤에
   있어야 한다.

   * 공백 문자,
   * ASCII 문자 중 하나 ``- : / ' " < ( [ {``
   * 유사한 non-ASCII 구분 문자. [#pre-chars]_

7. 인라인 마크업 종료 스트링은 텍스트 블럭을 종료시키거나 아래의 문자 바로 앞에
   있어야 한다.

   * 공백 문자,
   * ASCII 문자 중 하나 ``- . , : ; ! ? \ / ' " ) ] } >``
   * 유사한 non-ASCII 구분 문자. [#post-chars]_

.. [#openers]    `Unicode categories`_ `Ps` (Open), `Pi` (Initial quote),
                 or `Pf` (Final quote). [#uni-version]_
.. [#closers]    Unicode categories `Pe` (Close), `Pi` (Initial quote),
                 or `Pf` (Final quote). [#uni-version]_
.. [#pre-chars]  Unicode categories `Ps` (Open), `Pi` (Initial quote),
                 `Pf` (Final quote), `Pd` (Dash), or `Po` (Other). [#uni-version]_
.. [#post-chars] Unicode categories  `Pe` (Close), `Pi` (Initial quote),
                 `Pf` (Final quote), `Pd` (Dash), or `Po` (Other). [#uni-version]_

.. [#uni-version] 유니코드 표준의 발전에 따라 일부 문자의 카테고리가 변경되었다.
   Docutils 0.13은 `Unicode version 5.2.0`_\ 을 사용한다.

.. _Unicode categories:
   http://www.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values
.. _Unicode version 5.2.0: http://www.unicode.org/Public/5.2.0/
.. _quotation marks in international usage:
   http://en.wikipedia.org/wiki/Quotation_mark,_non-English_usage

인라인 마크업 인식 규정은 이스케이핑 없는 마크업 용도가 아닌 "*", "`", "_", "|"의 사용의
90%가 가능하도록 고안되었다. 예를 들어 아래의 문장들은 인라인 마크업 스트링을 포함하지
않는 것으로 인식된다:

- 2 * x  a ** b  (* BOM32_* ` `` _ __ | (breaks rule 1)
- || (breaks rule 3)
- "*" '|' (*) [*] {*} <*>
  ‘*’ ‚*‘ ‘*‚ ’*’ ‚*’
  “*” „*“ “*„ ”*” „*”
  »*« ›*‹ «*» »*» ›*› (breaks rule 5)
- 2*x a**b O(N**2) e**(x*y) f(x)*f(y) a|b file*.*
  __init__ __init__()  (breaks rule 6)

아래의 인라인 마크업 예시에서 이스케이핑은 필요하지 않다:

- ``*2 * x  *a **b *.txt*`` (breaks rule 2; renders as "*2 * x  *a **b *.txt*")
- ``*2*x a**b O(N**2) e**(x*y) f(x)*f(y) a*(1+2)*``
  (breaks rule 7; renders as "*2*x a**b O(N**2) e**(x*y) f(x)*f(y) a*(1+2)*")

만약 코드 스니핏(snippets)을 표현하기 위해서라면 `인라인 리터럴`_\ 을 사용하는 것을
권장한다. 이것은 작성자의 판단에 달렸다.

이 경우 해석이 잘못 되는 것을 막기 위해서 literal-quoting 이나 이스케이핑이 필요하다::

    \*4, class\_, \*args, \**kwargs, \`TeX-quoted', \*ML, \*.txt

대부분의 경우, `인라인 리터럴`_\ 이나 `리터럴 블럭`_\ 을 사용하는 것이 가장
좋다. default 설정일 때, 한 번에 고정폭 글꼴로 변경된다::

    *4, class_, *args, **kwargs, `TeX-quoted', *ML, *.txt

단어 사이에 공백 문자를 사용하지 않는 언어의 경우(일본어, 중국어) `단순 인라인 마크업`_\
을 True로 설정하고 인라인 마크업을 이스케이프하는 것을 추천한다. 위에 있는 규정 6과 7을
위반하는 예시는 어떤 구조가 특별한 주의를 요하는지 보여준다.


.. _단순 인라인 마크업: ../../user/config.html#simple-inline-markup


인식 순서
-----------------

인라인 마크업 구분자는 여러 구조에 의해서 사용된다 따라서 모호성을 피하기
위해서 각 문자에 대한 지정된 인식 순서가 있어야 한다. 인라인 마크업의 인식
순서는 다음과 같다:

- 별표: `강한 강조`_ ("**") 는 강조_ ("*") 전에 일어난다.

- 백 쿼트: `인라인 리터럴`_ ("``")과 `인라인 내부 타겟`_
  (leading "_`", trailing "`")은 상호 독립적이며 `하이퍼링크 참조`_
  (leading "`", trailing "\`_")와 `해석된 텍스트`_ ("`") 구문 전에
  인식 된다.

- 뒤쪽 언더스코어: 각주 참조 ("[" + label + "]_")와
  단순 `하이퍼링크 참조`_ (name + trailing "_")는 상호 독립적이다.

- 수직 막대: `대체 참조`_ ("|")는 독립적으로 인식된다.

- `자립 하이퍼링크`_\ 는 가장 마지막에 인식된다.


문자 수준의 인라인 마크업
-----------------------------

단어 사이의 개별 문자에 백슬래쉬 이스케이프로 마크업 할 수 있다.
(위쪽의 `이스케이핑 메커니즘`_ 참고) 백슬래쉬 이스케이프는 임의의 텍스트를
인라인 마크업을 바로 뒤에 쓰도록 만드는 데 사용할 수 있다::

    Python ``list``\s use square bracket syntax.

백슬래쉬는 처리된 문서에서 사라질 것이다. 단어 "list"는 인라인 리터럴 텍스트로
나타날 것이고 문자 "s" 일반 텍스트로 스페이스 없이 바로 뒤에 써질 것이다.

임의의 텍스트는 백슬래쉬 이스케이프 된 공백문자를 사용하는 인라인 마크업 바로
앞에 위치한다::

    Possible in *re*\ ``Structured``\ *Text*, though not encouraged.

"re", "Structured", "Text"를 나누는 스페이스와 공백 문자는 처리된 문서에서
사라질 것이다.

.. CAUTION::

   문자 수준의 인라인 마크업을 위해 백슬래쉬 이스케이프를 사용하는 것은
   권장되지 않는다. 이러한 사용 방식은 처리되지 않은 문서의 가독성에 좋지 않은 영향을
   준다. 이 기능은 반드시 필요한 곳에만 사용하라.


강조
--------

독트리 요소: 강조.

시작 스트링 = 종료 스트링 = "*".

별표 하나로 둘러싸인 단어는 강조된다::

    이것은 *강조된 텍스트* 다.

강조된 텍스트는 일반적으로 이탤릭체로 변한다.


강한 강조
---------------

독트리 요소: strong.

시작 스트링 = 종료 스트링 = "**".

별표 두 개로 둘러싸인 텍스트는 강하게 강조된다::

    이것은 **강한 텍스트** 다.

강하게 강조된 텍스트는 일반적으로 굵게 변한다.


해석된 텍스트
----------------

독트리 요소: 명시적 암시적 기능과 처리에 따라 달라짐.

시작 스트링 = 종료 스트링 = "`".

해석된 텍스트(Interpreted text)는 요약, 링크, 인덱싱 또는 다른 처리를 위한 텍스트이지만
일반적으로 그대로 남겨진 텍스트를 의미한다. 해석된 텍스트는 백 쿼트
하나로 둘러싸여져있다::

    이것은 `해석된 텍스트` 이다.

해석된 텍스트의 기능(role)은 텍스트가 해석될 방식을 결정한다.
기능은 내부적으로 (위처럼 "기본 기능"로 사용되는 것처럼) 유추되거나 기능 마커
를 이용해서 외부적으로 표시될 수도 있다. 기능 마커는 콜론과 기능 이름과 다른
콜론으로 이루어져있다. 기능 이름은 하이픈, 언더스코어, 플러스기호, 콜론, 구두점
등으로 구분된 영어와 숫자로 이루어진 한 단어다; 공백 문자나 다른 문자는 허용되지
않는다. 기능 마커는 해석된 텍스트의 앞에 혹은 뒤에 붙어도 상관 없다;
결정은 작성자의 몫이다::

    :role:`해석된 텍스트`

    `해석된 텍스트`:role:

해석된 텍스트는 사용 가능한 기술적(descriptive) 인라인 마크업 구조를 확장할 수 있다.
강조_, `강한 강조`_, `인라인 리터럴`_, `하이퍼링크 참조`_\ 에
"title reference", "index entry", "acronym", "class", "red", "blinking" 등
원하는 것을 추가할 수 있다. 사전에 지정되어 있는 role만 인식된다; 정해지지 않은 role은
에러를 발생시킨다. 표준 기능의 핵심 세트는 레퍼런스 파서에 구현되어 있다;
각각에 대한 설명은 `reStructuredText Interpreted Text Roles`_\ 을 참고하라
role_ 명령어는 커스텀 해석된 텍스트 기능을 정하기 위해 사용할 수 있다.
또한 응용 프로그램은 특수 기능을 지원할 수 있다.


인라인 리터럴
---------------

독트리 요소: 리터럴(literal).

시작 스트링 = 종료 스트링 = "``".

더블 백쿼트로 싸인 텍스트는 인라인 리터럴(inline literal)로 취급된다::

    이 텍스트는 ``인라인 리터럴`` 예시다.

인라인 리터럴은 인식 규정에 따라 종료 스트링 컨텍스트에 두
백쿼트를 붙여서 쓰는 경우를 제외하고는 어떤 문자를 포함해도 된다.
인라인 리터럴 내에서는 백슬래쉬 이스케이프 해석을 포함해
마크업 해석이 전혀 이루어지지 않는다.

인라인 리터럴에서 개행은 불가능하다. reStructuredText 파서가
스페이스는 출력물에서 보존을 하지만 처리된 문서의 최종적인 모습은 출력 포맷터에
따라 다르다. 따라서 공백문자의 보존은 보장되지 않는다. 행 바꿈이나 다른 공백문자를
보존하는 것이 중요하다면 `리터럴 블럭`_\ 을 사용하라.

인라인 마크업은 짧은 코드를 표현할 때 유용하다::

    정규 표현식 ``[+-]?(\d+(\.\d*)?|\.\d+)`` 은은 지수가 없는
    부동소수점 숫자와 일치한다.


하이퍼링크 참조
--------------------

독트리 요소: 참조.

- Named hyperlink references:

  - 시작 스트링 없음, 종료 스트링 = "_".
  - 시작 스트링 = "`", 종료 스트링 = "\`_".  (구문 참조.)

- Anonymous hyperlink references:

  - 시작 스트링 없음, 종료 스트링 = "__".
  - 시작 스트링 = "`", 종료 스트링 = "\`__".  (구문 참조.)

하이퍼링크 참조는 독립적으로 인식되는 `자립 하이퍼링크`_\ 를
제외하고는 뒤쪽 언더스코어, "_"에 의해 표시된다. 언더스코어는 오른쪽을
가리키는 화살표로 생각될 수 있다. 뒤쪽 언더스코어는 하이퍼링크 참조로부터
가키리는 것이고, 앞쪽 언더스코어는 `하이퍼링크 타겟`_\ 을 가리키는 것이다.

하이퍼링크는 두 부분으로 구성되어 있다. 텍스트 본문에는 뒤쪽 언더스코어가 있는 참조 이름인
소스 링크(source link)가 있다. 또는 `익명 하이퍼링크`_\ 를 위해 두
개의 언더스코어가 있을 수 있다::

    See the Python_ home page for info.

매치되는 참조 이름이 있는 타겟 링크는 문서 어딘가에는 존재해야 한다.
자세한 설명은 `하이퍼링크 타겟`_\ 을 참고하라.

`익명 하이퍼링크`_\ 는 레퍼런스와 타겟을 매치시키기 위해 참조 이름을 쓰지
않는다. 하지만 그 외에는 이름이 있는 하이퍼링와 유사하게 작동한다.


임베디드 URI와 에일리어스
`````````````````````````

하이퍼링크 참조는 아래 처럼 타겟 URI나 (Docutils 0.11 이후) 하이퍼링크 참조를
화살 괄호 ("<...>") 안에 바로 집어넣을 수 있다::

    See the `Python home page <http://www.python.org>`_ for info.

    This `link <Python home page_>`_ is an alias to the link above.

이것은 아래와 정확히 똑같다::

    See the `Python home page`_ for info.

    This link_ is an alias to the link above.

    .. _Python home page: http://www.python.org
    .. _link: `Python home page`_

괄호에 싸인 URI 바로 앞에는 공백 문자가 와야 하고 종료 스트링 앞의 마지막 문자는
텍스트가 되어야 한다.

단일 뒤쪽 언더스코어가 있으면, 참조는 이름이 지정되고 같은 타겟 URI가
다시 참조된다. 뒤쪽 언더스코어가 두 개 있으면, 레퍼런스와 타겟은 모두 익명
처리 되고 타겟은 다시 참조되지 않는다. 이것은 "one-off" 하이퍼링크라고 한다::

    `RFC 2396 <http://www.rfc-editor.org/rfc/rfc2396.txt>`__ and `RFC
    2732 <http://www.rfc-editor.org/rfc/rfc2732.txt>`__ together
    define the syntax of URIs.

위의 예시는 아래와 같다::

    `RFC 2396`__ and `RFC 2732`__ together define the syntax of URIs.

    __ http://www.rfc-editor.org/rfc/rfc2396.txt
    __ http://www.rfc-editor.org/rfc/rfc2732.txt

`자립 하이퍼링크`_\ 는 파이썬 함수 문서의 예시에 있는 것 처럼
언더스코어로 끝나도 URI로 취급된다::

    `__init__ <http:example.py.html#__init__>`__

`자립 하이퍼링크`_\ 로 인식되지 않는 타겟 URI가 언더스코어로 끝나면
하이퍼링크 참조 파싱되는 것을 막기 위하여 백슬래쉬 이스케이프 되어야 한다::

    Use the `source <parrots.txt\_>`__.

위의 예시는 파일 ``parrots.txt``\ 에 대한 익명 참조를 만든다.

참조 텍스트가 화살괄호로 둘러싸인 URI나 하이퍼링크 참조가 아닌 텍스트로 끝나면
최소한 하나의 화살괄호는 백슬래쉬 이스케이프 되거나 이스케이프된 스페이스를 뒤에
써줘야 한다. 아래는 태그를 설명하는 제목에 대한 참조 세가지다.::

    See `HTML Element: \<a>`_, `HTML Element: <b\> `_, and
    `HTML Element: <c>\ `_.

참조 텍스트는 생략될 수 있다. 이 경우 URI는 참조 텍스트로 사용되기 위해 복제된다.
이것은 주소나 파일 이름이 바람직한 참조 텍스트인 상대 URI일 때 유용하다::

    See `<a_named_relative_link>`_ or `<an_anonymous_relative_link>`__
    for details.

.. CAUTION::

   이 구조는 일반적인 하이퍼링크의 유지나 작성을 쉽게 하지만 가독성을
   훼손시킨다. 특히 긴 인라인 URI의 경우 텍스트의 자연적인 흐름을 방해하기 쉽다.
   소스 형식으로 읽으려는 문서는 독립적인 블럭 레벨의 `하이퍼링크 타겟`_\
   을 사용할 것을 **강력히 권장한다**. 임베딩된 URI 구조는 오로지
   처리된 형식으로 읽도록 된 문서에 가장 적합하다.


인라인 내부 타겟
------------------------

독트리 요소: 타겟.

시작 스트링 = "_`", 종료 스트링 = "`".

인라인 인터널 타겟(Inline internal target)은 명시적 `내부 하이퍼링크 타겟`_\ 과 동일하지만 텍스트 안에서 나타난다. 신택스는
언더스코어와 백 쿼트로 시작한 다음 하이퍼링크 단어나 구가 오고 백쿼트로 끝난다.
인라인 인터널 타겟은 익명처리될 수 없다.

예를 들어 아래의 단락은 "Norwegian Blue"이라는 이름의 하이퍼링크 타겟을
포함하고 있다::

    Oh yes, the _`Norwegian Blue`.  What's, um, what's wrong with it?

중복된 참조 이름 해결 방법은 `암시적 하이퍼링크 타겟`_\  참고하라.


각주 참조
-------------

참고: 각주_

독트리 요소: `각주 레퍼런스`_.

환경 설정:
`각주 레퍼런스 <각주 레퍼런스 세팅_>`_,
`각주 레퍼런스 공백 정리`_.

.. _각주 레퍼런스: ../doctree.html#footnote-reference
.. _각주 레퍼런스 공백 정리:
   ../../user/config.html#trim-footnote-reference-space

시작 스트링 = "[", 종료 스트링 = "]_".

각각의 각주 참조(footnote reference)는 대괄호로 묶인 라벨과 끝 언더스코어로
구성되어 있다. 각주의 라벨은 아래 중 하나로 쓸 수 있다:

- 한 자리 이상의 숫자,

- 단일 "#" (`자동 넘버링 각주`_ 참조),

- 간단한 참조 이름이 뒤에 있는 "#" (an `자동 넘버링 레이블`_),
  or

- 단일 "*" (`자동 심벌 각주`_ 참고).

예시::

    Please RTFM [1]_.

    .. [1] Read The Fine Manual

`인라인 마크업 인식 규정`_\ 은 각주 참조 앞에 공백을 요구한다.
출력물에서 공백을 제거하고 싶으면 이스케이프된 공백 문자를 사용하거나
(`이스케이핑 메커니즘`_ 참고), `각주 레퍼런스 공백 정리`_ 환경 설정을
변경하라. `각주 레퍼런스 세팅`_\ 이 "superscript"로 설정되어 있으면
앞에 있는 공백은 기본적으로 제거된다.


인용 참조
-------------------

참고: 인용_

독트리 요소: `인용 참조`_.

.. _인용 참: ../doctree.html#citation_reference

시작 스트링 = "[", 종료 스트링 = "]_".

각각의 인용 참조(citation reference)는 대괄호로 묶인 라벨과 끝 언더스코어로
구성되어 있다. 인용 라벨은  단순한 `참조 이름`_\ 이며 대소문자 구별 없이
문자, 숫자, 내부 하이픈, 언더스코어, 마침표 등으로 이루어진 공백 없는 단일
단어이다.

예시::

    다음이 인용 참조다: [CIT2002]_.


대체 참조
-----------------------

독트리 요소: 대체 참조, 참조.

시작 스트링 = "|", 종료 스트링 = "|" (추가적으로 "_"나 "__"가 뒤에 올 수 있음.)

수직 막대는 대체 참조(substitution reference) 텍스트를 감싸기 위해 사용 된다.
대체 참조는 "_"(지정)나 "__"(익명)를 덧붙여서 하이퍼링크 참조로 사용될 수도 있다;
대체 텍스트는 지정된 경우에 참조 텍스트로 사용된다.

처리 시스템은 대체 참조를 `대체 정의`_\ 에 대응하는 처리된 컨텐츠로
대체한다. 대체 정의는 인라인으로 호환가능한 요소를 생성한다.

예시::

    다음은 간단한 |substitution reference| 이다. 이것은 처리 시스템에 의해
    대체될 것이다.

    다음은 |substitution and hyperlink reference|_ 조합이다. 대체 텍스트와
    요소는 대체될 뿐 아니라 "substitution and hyperlink reference" 타겟을
    참조할 것이다.

.. _자립 하이퍼링크:

자립 하이퍼링크
---------------------

독트리 요소: 참조.

시작 스트링이나 종료 스트링 없음.

텍스트 블럭에 있는 URI(절대 URI [#URI]_ 나 자립(standalone) 이메일 주소)는
URI 자체가 링크의 텍스트인 일반 외부 하이퍼링크로 처리된다.
예시::

    See http://www.python.org for info.

HTML에서는 아래처럼 마크업 된다::

    See <a href="http://www.python.org">http://www.python.org</a> for
    info.

인식되는 형식의 URI는 두 가지다:

1. 절대 URI. 절대 URI는 스킴(scheme)과 콜론(":") 하나, 스킴에 따라
   해석되는 스킴 고유(scheme-specific) 부분으로 구성된다.

   스킴은 "http", "ftp", "malito", "telnet" 같은 프로토콜(protocol)의
   이름이다. 스킴은 첫 문자와 뒤 따르는 문자, 숫자, "+", "-", "."로
   구성된다. 인식은 `Official IANA Registry of URI Schemes`_\ 과
   W3C의 `Retired Index of WWW Addressing Schemes`_\ 에 의해 알려진
   스킴으로 제한 된다.

   리소스 식별자(resource indentifier)의 스킴 고유 부분은 계층적
   (hierarchical)이거나 불투명(opaque)할 수 있다:

   - 계층적 식별자는 하나 또는 구 개의 슬래쉬로 시작하고 경로(path)의
     계층적 성분(component)를 분리하기 위해 슬래쉬를 사용한다.
     아래는 웹 페이지와 FTP 사이트의 예시다::

         http://www.python.org

         ftp://ftp.python.org/pub/python

   - Opaque 식별자는 슬래쉬로 시작하지 않는다. 아래는 이베일 주소와
     뉴스그룹 예시다::

         mailto:someone@somewhere.com

         news:comp.lang.python

   쿼리(queries), 프래그먼트(fragments), %-이스케이프 된 시퀀스(sequences)
   로 인해 URI는 복잡해질 수 있다. reStructuredText 파서는
   RFC2396_\ 와 RFC2732_\ 에 정의된 절대 URI는 모두 인식할 수 있다.

2. 자립형 이메일 주소는 "mailto:" 스킴이 있는 절대 URI로 처리된다.
   예시::

       someone@somewhere.com

URI가 화살괄호(">")로 끝나지 않으면 마지막에 에 있는 마침표는 URI의
일부로 인식되지 않는다. 백슬래쉬는 URI 문자로 유효한 별표나 언더스코어 같은
마크업 문자를 이스케이프 하기 위해서 URI 내에서 사용될 수 있다.
(위쪽의 `이스케이핑 메커니즘`_ 참고).

.. [#URI] Uniform Resource Identifier.  URI는 URL(Uniform Resource
   Locators)의 일반 형식이다. URI 신택스는 RFC2396_ 와 RFC2732_ 를
   참고하라.


단위
=====

(New in Docutils 0.3.10.)

모든 측정값은 표준 (비과학) 표기법에 있는 양의 부동소수점 숫자와, 하나 이상의
공백으로 구분되어 있는 단위로 구성되어 있다.

단위는 레퍼런스 메뉴얼에 명시적으로 언급되었을 때만 지원된다.


길이 단위
------------

아래의 길이 단위는 reStructuredText 파서에 의해 지원된다:

* em (ems, 글꼴의 높이)
* ex (x-height, 글자 "x"의 높이)
* px (pixels, 캔버스(canvas) 해상도와 관련)
* in (inches; 1in=2.54cm)
* cm (centimeters; 1cm=10mm)
* mm (millimeters)
* pt (points; 1pt=1/72in)
* pc (picas; 1pc=12pt)

이 세트는 `CSS의 길이 단위`_\ 와 일치한다.

(리스트와 설명은 http://www.htmlhelp.com/reference/css/units.html#length\
를 참고했다.)

다음은 모두 유효한 길이 단위이다: "1.5em", "20 mm", ".5in".

단위가 없는 길이 값은 writer 종속 기본 설정으로 작성된다 (예, `html4css1`의
px, `latex2e`의 pt). 자세한 내용은 `user doc`__\ 에 있는 writer 지정
도큐먼테이션을 참고하라.

.. _CSS의 길이 단위:
   http://www.w3.org/TR/CSS2/syndata.html#length-units

__ ../../user/

퍼센트 단위
----------------

퍼센트 값은 단위로 퍼센트 기호("%")를 사용한다. 퍼센트 값은 값이
발생하는 컨텍스트에 따라 다른 값들에 비례한다.


----------------
 에러 처리
----------------

독트리 요소: 시스템 메시지, 문제가 있는 사항.

마크업 오류는 `PEP 258`_\ 에 있는 설명에 따라 처리된다.


.. _reStructuredText: http://docutils.sourceforge.net/rst.html
.. _Docutils: http://docutils.sourceforge.net/
.. _The Docutils Document Tree: ../doctree.html
.. _Docutils Generic DTD: ../docutils.dtd
.. _변환:
   http://docutils.sourceforge.net/docutils/transforms/
.. _Grouch: http://www.mems-exchange.org/software/grouch/
.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt
.. _독타이틀 변환:
.. _독인포 변환:
   http://docutils.sourceforge.net/docutils/transforms/frontmatter.py
.. _getopt.py:
   http://www.python.org/doc/current/lib/module-getopt.html
.. _GNU libc getopt_long():
   http://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Options.html
.. _독테스트 모듈:
   http://www.python.org/doc/current/lib/module-doctest.html
.. _이맥스 테이블 모드: http://table.sourceforge.net/
.. _Official IANA Registry of URI Schemes:
   http://www.iana.org/assignments/uri-schemes
.. _Retired Index of WWW Addressing Schemes:
   http://www.w3.org/Addressing/schemes.html
.. _World Wide Web Consortium: http://www.w3.org/
.. _HTML Techniques for Web Content Accessibility Guidelines:
   http://www.w3.org/TR/WCAG10-HTML-TECHS/#link-text
.. _image: directives.html#image
.. _replace: directives.html#replace
.. _meta: directives.html#meta
.. _figure: directives.html#figure
.. _admonition: directives.html#admonitions
.. _role: directives.html#custom-interpreted-text-roles
.. _reStructuredText Directives: directives.html
.. _reStructuredText Interpreted Text Roles: roles.html
.. _RFC2396: http://www.rfc-editor.org/rfc/rfc2396.txt
.. _RFC2732: http://www.rfc-editor.org/rfc/rfc2732.txt
.. _Zope: http://www.zope.com/
.. _PEP 258: ../../peps/pep-0258.html


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
